"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/layout",{

/***/ "(app-pages-browser)/./app/globals.css":
/*!*************************!*\
  !*** ./app/globals.css ***!
  \*************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (\"e31df9a66d04\");\nif (true) { module.hot.accept() }\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL2FwcC9nbG9iYWxzLmNzcyIsIm1hcHBpbmdzIjoiOzs7O0FBQUEsaUVBQWUsY0FBYztBQUM3QixJQUFJLElBQVUsSUFBSSxpQkFBaUIiLCJzb3VyY2VzIjpbIi9Vc2Vycy9sbmF1c2FuL0RvY3VtZW50cy9HYXN0b3MgVjIvYXBwL2dsb2JhbHMuY3NzIl0sInNvdXJjZXNDb250ZW50IjpbImV4cG9ydCBkZWZhdWx0IFwiZTMxZGY5YTY2ZDA0XCJcbmlmIChtb2R1bGUuaG90KSB7IG1vZHVsZS5ob3QuYWNjZXB0KCkgfVxuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./app/globals.css\n"));

/***/ }),

/***/ "(app-pages-browser)/./context/transaction-context.tsx":
/*!*****************************************!*\
  !*** ./context/transaction-context.tsx ***!
  \*****************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   TransactionProvider: () => (/* binding */ TransactionProvider),\n/* harmony export */   useTransactions: () => (/* binding */ useTransactions)\n/* harmony export */ });\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-dev-runtime */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/jsx-dev-runtime.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var _components_ui_use_toast__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @/components/ui/use-toast */ \"(app-pages-browser)/./components/ui/use-toast.ts\");\n/* harmony import */ var _components_providers_supabase_provider__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @/components/providers/supabase-provider */ \"(app-pages-browser)/./components/providers/supabase-provider.tsx\");\n/* __next_internal_client_entry_do_not_use__ TransactionProvider,useTransactions auto */ \nvar _s = $RefreshSig$(), _s1 = $RefreshSig$();\n\n\n\nconst TransactionContext = /*#__PURE__*/ (0,react__WEBPACK_IMPORTED_MODULE_1__.createContext)(undefined);\nfunction TransactionProvider(param) {\n    let { children } = param;\n    _s();\n    const { supabase } = (0,_components_providers_supabase_provider__WEBPACK_IMPORTED_MODULE_3__.useSupabase)();\n    const [transactions, setTransactions] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)([]);\n    const [dollarValues, setDollarValues] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)([]);\n    const [optimisticTransactions, addOptimisticTransaction] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useOptimistic)(transactions, {\n        \"TransactionProvider.useOptimistic\": (state, param)=>{\n            let { action, data } = param;\n            if (action === \"add\") {\n                return [\n                    ...state,\n                    data\n                ];\n            } else if (action === \"update\") {\n                return state.map({\n                    \"TransactionProvider.useOptimistic\": (t)=>t.id === data.id ? {\n                            ...t,\n                            ...data.transaction\n                        } : t\n                }[\"TransactionProvider.useOptimistic\"]);\n            } else if (action === \"delete\") {\n                return state.filter({\n                    \"TransactionProvider.useOptimistic\": (t)=>t.id !== data.id\n                }[\"TransactionProvider.useOptimistic\"]);\n            }\n            return state;\n        }\n    }[\"TransactionProvider.useOptimistic\"]);\n    const [optimisticDollarValues, addOptimisticDollarValue] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useOptimistic)(dollarValues, {\n        \"TransactionProvider.useOptimistic\": (state, param)=>{\n            let { action, data } = param;\n            if (action === \"update\") {\n                const existingIndex = state.findIndex({\n                    \"TransactionProvider.useOptimistic.existingIndex\": (d)=>d.month === data.month\n                }[\"TransactionProvider.useOptimistic.existingIndex\"]);\n                if (existingIndex >= 0) {\n                    return state.map({\n                        \"TransactionProvider.useOptimistic\": (d)=>d.month === data.month ? data : d\n                    }[\"TransactionProvider.useOptimistic\"]);\n                } else {\n                    return [\n                        ...state,\n                        data\n                    ];\n                }\n            }\n            return state;\n        }\n    }[\"TransactionProvider.useOptimistic\"]);\n    const { toast } = (0,_components_ui_use_toast__WEBPACK_IMPORTED_MODULE_2__.useToast)();\n    const storageId = (0,react__WEBPACK_IMPORTED_MODULE_1__.useId)();\n    // Cargar transacciones y valores del dólar desde localStorage al iniciar\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)({\n        \"TransactionProvider.useEffect\": ()=>{\n            if (!supabase) return;\n            const loadData = {\n                \"TransactionProvider.useEffect.loadData\": async ()=>{\n                    try {\n                        const { data: { user }, error: userError } = await supabase.auth.getUser();\n                        if (userError) {\n                            console.error('Error al obtener usuario:', userError);\n                            throw userError;\n                        }\n                        if (!user) {\n                            console.log('No hay usuario autenticado');\n                            return;\n                        }\n                        console.log('Usuario autenticado:', user.id);\n                        const { data: transactionsData, error: transactionsError } = await supabase.from('expenses').select('*').eq('user_id', user.id).order('created_at', {\n                            ascending: false\n                        });\n                        if (transactionsError) {\n                            console.error('Error al cargar transacciones:', transactionsError);\n                            throw transactionsError;\n                        }\n                        console.log('Transacciones cargadas:', transactionsData);\n                        setTransactions(transactionsData || []);\n                        const { data: dollarValuesData, error: dollarValuesError } = await supabase.from('dollar_values').select('*').order('month', {\n                            ascending: false\n                        });\n                        if (dollarValuesError) {\n                            console.error('Error al cargar valores del dólar:', dollarValuesError);\n                            throw dollarValuesError;\n                        }\n                        console.log('Valores del dólar cargados:', dollarValuesData);\n                        setDollarValues(dollarValuesData || []);\n                    } catch (error) {\n                        console.error('Error al cargar datos:', error);\n                        toast({\n                            title: 'Error al cargar los datos',\n                            description: error instanceof Error ? error.message : 'Error desconocido',\n                            variant: 'destructive'\n                        });\n                    }\n                }\n            }[\"TransactionProvider.useEffect.loadData\"];\n            loadData();\n        }\n    }[\"TransactionProvider.useEffect\"], [\n        supabase\n    ]);\n    // Guardar transacciones y valores del dólar en localStorage cuando cambian\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)({\n        \"TransactionProvider.useEffect\": ()=>{\n            localStorage.setItem(\"transactions-\".concat(storageId), JSON.stringify(transactions));\n        }\n    }[\"TransactionProvider.useEffect\"], [\n        transactions,\n        storageId\n    ]);\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)({\n        \"TransactionProvider.useEffect\": ()=>{\n            localStorage.setItem(\"dollar-values-\".concat(storageId), JSON.stringify(dollarValues));\n        }\n    }[\"TransactionProvider.useEffect\"], [\n        dollarValues,\n        storageId\n    ]);\n    // Agregar una nueva transacción\n    const addTransaction = async (transaction)=>{\n        if (!supabase) return;\n        try {\n            const { data: { user } } = await supabase.auth.getUser();\n            if (!user) {\n                console.error('No se pudo obtener el usuario autenticado');\n                return;\n            }\n            const expenseToInsert = {\n                amount: transaction.amount,\n                description: transaction.description,\n                date: transaction.date,\n                category_id: transaction.category_id,\n                user_id: user.id,\n                type: transaction.type\n            };\n            console.log('Insertando en Supabase:', expenseToInsert);\n            const { data, error } = await supabase.from('expenses').insert([\n                expenseToInsert\n            ]).select().single();\n            console.log('Respuesta de Supabase:', {\n                data,\n                error\n            });\n            if (error) throw error;\n            // Recargar todas las transacciones para asegurar consistencia\n            const { data: transactionsData, error: transactionsError } = await supabase.from('expenses').select('*').eq('user_id', user.id).order('created_at', {\n                ascending: false\n            });\n            if (transactionsError) throw transactionsError;\n            console.log('Transacciones actualizadas:', transactionsData);\n            setTransactions(transactionsData || []);\n            toast({\n                title: 'Transacción agregada correctamente'\n            });\n        } catch (error) {\n            console.error('Error al agregar transacción:', error);\n            toast({\n                title: 'Error al agregar la transacción'\n            });\n            throw error;\n        }\n    };\n    // Actualizar una transacción existente\n    const updateTransaction = async (id, transaction)=>{\n        if (!supabase) return;\n        try {\n            // Adaptar los campos al esquema de expenses\n            const expenseToUpdate = {};\n            if (transaction.amount !== undefined) expenseToUpdate.amount = transaction.amount;\n            if (transaction.description !== undefined) expenseToUpdate.description = transaction.description;\n            if (transaction.date !== undefined) expenseToUpdate.date = transaction.date;\n            if (transaction.category_id !== undefined) expenseToUpdate.category_id = transaction.category_id;\n            if (transaction.type !== undefined) expenseToUpdate.type = transaction.type;\n            console.log('Actualizando transacción:', {\n                id,\n                ...expenseToUpdate\n            });\n            const { data, error } = await supabase.from('expenses').update(expenseToUpdate).eq('id', id).select().single();\n            if (error) throw error;\n            console.log('Transacción actualizada:', data);\n            // Recargar todas las transacciones para asegurar consistencia\n            const { data: transactionsData, error: transactionsError } = await supabase.from('expenses').select('*').order('created_at', {\n                ascending: false\n            });\n            if (transactionsError) throw transactionsError;\n            console.log('Transacciones actualizadas:', transactionsData);\n            setTransactions(transactionsData || []);\n            toast({\n                title: 'Transacción actualizada correctamente'\n            });\n        } catch (error) {\n            console.error('Error al actualizar transacción:', error);\n            toast({\n                title: 'Error al actualizar la transacción'\n            });\n            throw error;\n        }\n    };\n    // Eliminar una transacción\n    const deleteTransaction = async (id)=>{\n        if (!supabase) return;\n        try {\n            console.log('Eliminando transacción:', id);\n            const { error } = await supabase.from('expenses').delete().eq('id', id);\n            if (error) throw error;\n            // Recargar todas las transacciones para asegurar consistencia\n            const { data: transactionsData, error: transactionsError } = await supabase.from('expenses').select('*').order('created_at', {\n                ascending: false\n            });\n            if (transactionsError) throw transactionsError;\n            console.log('Transacciones actualizadas:', transactionsData);\n            setTransactions(transactionsData || []);\n            toast({\n                title: 'Transacción eliminada correctamente'\n            });\n        } catch (error) {\n            console.error('Error al eliminar transacción:', error);\n            toast({\n                title: 'Error al eliminar la transacción'\n            });\n            throw error;\n        }\n    };\n    // Obtener transacciones de un mes específico\n    const getMonthTransactions = (month)=>{\n        return transactions.filter((t)=>t.date.startsWith(month));\n    };\n    // Obtener resumen de un mes específico\n    const getMonthSummary = (month)=>{\n        const monthTransactions = getMonthTransactions(month);\n        const income = monthTransactions.filter((t)=>t.type === 'ingreso').reduce((sum, t)=>sum + t.amount, 0);\n        const expense = monthTransactions.filter((t)=>t.type === 'gasto').reduce((sum, t)=>sum + t.amount, 0);\n        return {\n            month,\n            income,\n            expense,\n            balance: income - expense\n        };\n    };\n    // Obtener resumen por categoría para un mes específico\n    const getMonthCategorySummary = (month, type)=>{\n        const monthTransactions = getMonthTransactions(month).filter((t)=>t.type === type);\n        const categorySummary = {};\n        monthTransactions.forEach((transaction)=>{\n            if (!categorySummary[transaction.category_id]) {\n                categorySummary[transaction.category_id] = 0;\n            }\n            categorySummary[transaction.category_id] += transaction.amount;\n        });\n        return Object.entries(categorySummary).map((param)=>{\n            let [category, amount] = param;\n            return {\n                category,\n                amount\n            };\n        }).sort((a, b)=>b.amount - a.amount);\n    };\n    // Obtener los últimos 6 meses para el gráfico de barras\n    const getLastSixMonthsSummary = ()=>{\n        const today = new Date();\n        const months = [];\n        for(let i = 0; i < 6; i++){\n            const d = new Date(today.getFullYear(), today.getMonth() - i, 1);\n            const month = \"\".concat(d.getFullYear(), \"-\").concat(String(d.getMonth() + 1).padStart(2, '0'));\n            months.push(month);\n        }\n        return months.map((month)=>getMonthSummary(month)).reverse();\n    };\n    // Obtener todos los meses del año actual para el gráfico de líneas\n    const getAllMonthsSummary = ()=>{\n        const currentYear = new Date().getFullYear();\n        const months = [];\n        for(let i = 0; i < 12; i++){\n            const month = \"\".concat(currentYear, \"-\").concat(String(i + 1).padStart(2, '0'));\n            months.push(month);\n        }\n        return months.map((month)=>getMonthSummary(month));\n    };\n    // Obtener el valor del dólar para un mes específico\n    const getDollarValue = (month)=>{\n        return dollarValues.find((d)=>d.month === month);\n    };\n    // Actualizar el valor del dólar para un mes específico\n    const updateDollarValue = async (month, value)=>{\n        if (!supabase) return;\n        try {\n            const { data: { user } } = await supabase.auth.getUser();\n            if (!user) {\n                console.error('No se pudo obtener el usuario autenticado');\n                return;\n            }\n            const existingDollar = dollarValues.find((d)=>d.month === month);\n            const dollarValue = {\n                id: existingDollar === null || existingDollar === void 0 ? void 0 : existingDollar.id,\n                month,\n                value,\n                user_id: user.id,\n                updated_at: new Date().toISOString()\n            };\n            const { data, error } = await supabase.from('dollar_values').upsert(dollarValue, {\n                onConflict: 'month'\n            }).select().single();\n            if (error) throw error;\n            setDollarValues((prev)=>{\n                const existingIndex = prev.findIndex((d)=>d.month === month);\n                if (existingIndex >= 0) {\n                    return prev.map((d)=>d.month === month ? data : d);\n                } else {\n                    return [\n                        ...prev,\n                        data\n                    ];\n                }\n            });\n            toast({\n                title: 'Valor del dólar actualizado correctamente'\n            });\n        } catch (error) {\n            console.error('Error al actualizar valor del dólar:', error);\n            toast({\n                title: 'Error al actualizar el valor del dólar'\n            });\n            throw error;\n        }\n    };\n    return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(TransactionContext.Provider, {\n        value: {\n            transactions,\n            dollarValues,\n            addTransaction,\n            updateTransaction,\n            deleteTransaction,\n            getMonthTransactions,\n            getMonthSummary,\n            getLastSixMonthsSummary,\n            getAllMonthsSummary,\n            getDollarValue,\n            updateDollarValue,\n            getMonthCategorySummary\n        },\n        children: children\n    }, void 0, false, {\n        fileName: \"/Users/lnausan/Documents/Gastos V2/context/transaction-context.tsx\",\n        lineNumber: 377,\n        columnNumber: 5\n    }, this);\n}\n_s(TransactionProvider, \"pQ/ue/FYH0ZiaogyhZo2T8/D67Y=\", false, function() {\n    return [\n        _components_providers_supabase_provider__WEBPACK_IMPORTED_MODULE_3__.useSupabase,\n        react__WEBPACK_IMPORTED_MODULE_1__.useOptimistic,\n        react__WEBPACK_IMPORTED_MODULE_1__.useOptimistic,\n        _components_ui_use_toast__WEBPACK_IMPORTED_MODULE_2__.useToast,\n        react__WEBPACK_IMPORTED_MODULE_1__.useId\n    ];\n});\n_c = TransactionProvider;\nfunction useTransactions() {\n    _s1();\n    const context = (0,react__WEBPACK_IMPORTED_MODULE_1__.useContext)(TransactionContext);\n    if (context === undefined) {\n        throw new Error(\"useTransactions must be used within a TransactionProvider\");\n    }\n    return context;\n}\n_s1(useTransactions, \"b9L3QQ+jgeyIrH0NfHrJ8nn7VMU=\");\nvar _c;\n$RefreshReg$(_c, \"TransactionProvider\");\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL2NvbnRleHQvdHJhbnNhY3Rpb24tY29udGV4dC50c3giLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7O0FBSTZHO0FBRXpEO0FBQ2tCO0FBa0J0RSxNQUFNUSxtQ0FBcUJSLG9EQUFhQSxDQUFxQ1M7QUFFdEUsU0FBU0Msb0JBQW9CLEtBQTJDO1FBQTNDLEVBQUVDLFFBQVEsRUFBaUMsR0FBM0M7O0lBQ2xDLE1BQU0sRUFBRUMsUUFBUSxFQUFFLEdBQUdMLG9GQUFXQTtJQUNoQyxNQUFNLENBQUNNLGNBQWNDLGdCQUFnQixHQUFHWCwrQ0FBUUEsQ0FBZ0IsRUFBRTtJQUNsRSxNQUFNLENBQUNZLGNBQWNDLGdCQUFnQixHQUFHYiwrQ0FBUUEsQ0FBZ0IsRUFBRTtJQUVsRSxNQUFNLENBQUNjLHdCQUF3QkMseUJBQXlCLEdBQUdiLG9EQUFhQSxDQUd0RVE7NkNBQWMsQ0FBQ007Z0JBQU8sRUFBRUMsTUFBTSxFQUFFQyxJQUFJLEVBQUU7WUFDdEMsSUFBSUQsV0FBVyxPQUFPO2dCQUNwQixPQUFPO3VCQUFJRDtvQkFBT0U7aUJBQUs7WUFDekIsT0FBTyxJQUFJRCxXQUFXLFVBQVU7Z0JBQzlCLE9BQU9ELE1BQU1HLEdBQUc7eURBQUMsQ0FBQ0MsSUFBT0EsRUFBRUMsRUFBRSxLQUFLSCxLQUFLRyxFQUFFLEdBQUc7NEJBQUUsR0FBR0QsQ0FBQzs0QkFBRSxHQUFHRixLQUFLSSxXQUFXO3dCQUFDLElBQUlGOztZQUM5RSxPQUFPLElBQUlILFdBQVcsVUFBVTtnQkFDOUIsT0FBT0QsTUFBTU8sTUFBTTt5REFBQyxDQUFDSCxJQUFNQSxFQUFFQyxFQUFFLEtBQUtILEtBQUtHLEVBQUU7O1lBQzdDO1lBQ0EsT0FBT0w7UUFDVDs7SUFFQSxNQUFNLENBQUNRLHdCQUF3QkMseUJBQXlCLEdBQUd2QixvREFBYUEsQ0FHdEVVOzZDQUFjLENBQUNJO2dCQUFPLEVBQUVDLE1BQU0sRUFBRUMsSUFBSSxFQUFFO1lBQ3RDLElBQUlELFdBQVcsVUFB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N0IsbUJBQW1CNkcsUUFBUTtRQUMxQlIsT0FBTztZQUNMaEc7WUFDQUU7WUFDQThDO1lBQ0FTO1lBQ0FHO1lBQ0FFO1lBQ0FFO1lBQ0FnQjtZQUNBVztZQUNBRTtZQUNBRTtZQUNBeEI7UUFDRjtrQkFFQ3pFOzs7Ozs7QUFHUDtHQWhYZ0JEOztRQUNPSCxnRkFBV0E7UUFJMkJGLGdEQUFhQTtRQWNiQSxnREFBYUE7UUFldERDLDhEQUFRQTtRQUNSRix3Q0FBS0E7OztLQW5DVE07QUFrWFQsU0FBUzRHOztJQUNkLE1BQU1DLFVBQVV0SCxpREFBVUEsQ0FBQ087SUFDM0IsSUFBSStHLFlBQVk5RyxXQUFXO1FBQ3pCLE1BQU0sSUFBSTZDLE1BQU07SUFDbEI7SUFDQSxPQUFPaUU7QUFDVDtJQU5nQkQiLCJzb3VyY2VzIjpbIi9Vc2Vycy9sbmF1c2FuL0RvY3VtZW50cy9HYXN0b3MgVjIvY29udGV4dC90cmFuc2FjdGlvbi1jb250ZXh0LnRzeCJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBjbGllbnRcIlxuXG5pbXBvcnQgdHlwZSBSZWFjdCBmcm9tIFwicmVhY3RcIlxuXG5pbXBvcnQgeyBjcmVhdGVDb250ZXh0LCB1c2VDb250ZXh0LCB1c2VFZmZlY3QsIHVzZVN0YXRlLCB1c2VJZCwgdXNlT3B0aW1pc3RpYywgc3RhcnRUcmFuc2l0aW9uIH0gZnJvbSBcInJlYWN0XCJcbmltcG9ydCB0eXBlIHsgVHJhbnNhY3Rpb24sIE1vbnRoU3VtbWFyeSwgRG9sbGFyVmFsdWUgfSBmcm9tIFwiQC90eXBlcy90cmFuc2FjdGlvblwiXG5pbXBvcnQgeyB1c2VUb2FzdCB9IGZyb20gXCJAL2NvbXBvbmVudHMvdWkvdXNlLXRvYXN0XCJcbmltcG9ydCB7IHVzZVN1cGFiYXNlIH0gZnJvbSAnQC9jb21wb25lbnRzL3Byb3ZpZGVycy9zdXBhYmFzZS1wcm92aWRlcidcbmltcG9ydCB7IHRvYXN0IH0gZnJvbSAnc29ubmVyJ1xuXG5pbnRlcmZhY2UgVHJhbnNhY3Rpb25Db250ZXh0VHlwZSB7XG4gIHRyYW5zYWN0aW9uczogVHJhbnNhY3Rpb25bXVxuICBkb2xsYXJWYWx1ZXM6IERvbGxhclZhbHVlW11cbiAgYWRkVHJhbnNhY3Rpb246ICh0cmFuc2FjdGlvbjogT21pdDxUcmFuc2FjdGlvbiwgXCJpZFwiIHwgXCJjcmVhdGVkX2F0XCIgfCBcInVwZGF0ZWRfYXRcIiB8IFwidXNlcl9pZFwiPikgPT4gUHJvbWlzZTx2b2lkPlxuICB1cGRhdGVUcmFuc2FjdGlvbjogKGlkOiBzdHJpbmcsIHRyYW5zYWN0aW9uOiBQYXJ0aWFsPFRyYW5zYWN0aW9uPikgPT4gUHJvbWlzZTx2b2lkPlxuICBkZWxldGVUcmFuc2FjdGlvbjogKGlkOiBzdHJpbmcpID0+IFByb21pc2U8dm9pZD5cbiAgZ2V0TW9udGhUcmFuc2FjdGlvbnM6IChtb250aDogc3RyaW5nKSA9PiBUcmFuc2FjdGlvbltdXG4gIGdldE1vbnRoU3VtbWFyeTogKG1vbnRoOiBzdHJpbmcpID0+IE1vbnRoU3VtbWFyeVxuICBnZXRMYXN0U2l4TW9udGhzU3VtbWFyeTogKCkgPT4gTW9udGhTdW1tYXJ5W11cbiAgZ2V0QWxsTW9udGhzU3VtbWFyeTogKCkgPT4gTW9udGhTdW1tYXJ5W11cbiAgZ2V0RG9sbGFyVmFsdWU6IChtb250aDogc3RyaW5nKSA9PiBEb2xsYXJWYWx1ZSB8IHVuZGVmaW5lZFxuICB1cGRhdGVEb2xsYXJWYWx1ZTogKG1vbnRoOiBzdHJpbmcsIHZhbHVlOiBudW1iZXIpID0+IFByb21pc2U8dm9pZD5cbiAgZ2V0TW9udGhDYXRlZ29yeVN1bW1hcnk6IChtb250aDogc3RyaW5nLCB0eXBlOiBcImluZ3Jlc29cIiB8IFwiZ2FzdG9cIikgPT4geyBjYXRlZ29yeTogc3RyaW5nOyBhbW91bnQ6IG51bWJlciB9W11cbn1cblxuY29uc3QgVHJhbnNhY3Rpb25Db250ZXh0ID0gY3JlYXRlQ29udGV4dDxUcmFuc2FjdGlvbkNvbnRleHRUeXBlIHwgdW5kZWZpbmVkPih1bmRlZmluZWQpXG5cbmV4cG9ydCBmdW5jdGlvbiBUcmFuc2FjdGlvblByb3ZpZGVyKHsgY2hpbGRyZW4gfTogeyBjaGlsZHJlbjogUmVhY3QuUmVhY3ROb2RlIH0pIHtcbiAgY29uc3QgeyBzdXBhYmFzZSB9ID0gdXNlU3VwYWJhc2UoKVxuICBjb25zdCBbdHJhbnNhY3Rpb25zLCBzZXRUcmFuc2FjdGlvbnNdID0gdXNlU3RhdGU8VHJhbnNhY3Rpb25bXT4oW10pXG4gIGNvbnN0IFtkb2xsYXJWYWx1ZXMsIHNldERvbGxhclZhbHVlc10gPSB1c2VTdGF0ZTxEb2xsYXJWYWx1ZVtdPihbXSlcblxuICBjb25zdCBbb3B0aW1pc3RpY1RyYW5zYWN0aW9ucywgYWRkT3B0aW1pc3RpY1RyYW5zYWN0aW9uXSA9IHVzZU9wdGltaXN0aWM8XG4gICAgVHJhbnNhY3Rpb25bXSxcbiAgICB7IGFjdGlvbjogXCJhZGRcIiB8IFwidXBkYXRlXCIgfCBcImRlbGV0ZVwiOyBkYXRhOiBhbnkgfVxuICA+KHRyYW5zYWN0aW9ucywgKHN0YXRlLCB7IGFjdGlvbiwgZGF0YSB9KSA9PiB7XG4gICAgaWYgKGFjdGlvbiA9PT0gXCJhZGRcIikge1xuICAgICAgcmV0dXJuIFsuLi5zdGF0ZSwgZGF0YV1cbiAgICB9IGVsc2UgaWYgKGFjdGlvbiA9PT0gXCJ1cGRhdGVcIikge1xuICAgICAgcmV0dXJuIHN0YXRlLm1hcCgodCkgPT4gKHQuaWQgPT09IGRhdGEuaWQgPyB7IC4uLnQsIC4uLmRhdGEudHJhbnNhY3Rpb24gfSA6IHQpKVxuICAgIH0gZWxzZSBpZiAoYWN0aW9uID09PSBcImRlbGV0ZVwiKSB7XG4gICAgICByZXR1cm4gc3RhdGUuZmlsdGVyKCh0KSA9PiB0LmlkICE9PSBkYXRhLmlkKVxuICAgIH1cbiAgICByZXR1cm4gc3RhdGVcbiAgfSlcblxuICBjb25zdCBbb3B0aW1pc3RpY0RvbGxhclZhbHVlcywgYWRkT3B0aW1pc3RpY0RvbGxhclZhbHVlXSA9IHVzZU9wdGltaXN0aWM8XG4gICAgRG9sbGFyVmFsdWVbXSxcbiAgICB7IGFjdGlvbjogXCJ1cGRhdGVcIjsgZGF0YTogYW55IH1cbiAgPihkb2xsYXJWYWx1ZXMsIChzdGF0ZSwgeyBhY3Rpb24sIGRhdGEgfSkgPT4ge1xuICAgIGlmIChhY3Rpb24gPT09IFwidXBkYXRlXCIpIHtcbiAgICAgIGNvbnN0IGV4aXN0aW5nSW5kZXggPSBzdGF0ZS5maW5kSW5kZXgoKGQpID0+IGQubW9udGggPT09IGRhdGEubW9udGgpXG4gICAgICBpZiAoZXhpc3RpbmdJbmRleCA+PSAwKSB7XG4gICAgICAgIHJldHVybiBzdGF0ZS5tYXAoKGQpID0+IChkLm1vbnRoID09PSBkYXRhLm1vbnRoID8gZGF0YSA6IGQpKVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIFsuLi5zdGF0ZSwgZGF0YV1cbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHN0YXRlXG4gIH0pXG5cbiAgY29uc3QgeyB0b2FzdCB9ID0gdXNlVG9hc3QoKVxuICBjb25zdCBzdG9yYWdlSWQgPSB1c2VJZCgpXG5cbiAgLy8gQ2FyZ2FyIHRyYW5zYWNjaW9uZXMgeSB2YWxvcmVzIGRlbCBkw7NsYXIgZGVzZGUgbG9jYWxTdG9yYWdlIGFsIGluaWNpYXJcbiAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICBpZiAoIXN1cGFiYXNlKSByZXR1cm5cblxuICAgIGNvbnN0IGxvYWREYXRhID0gYXN5bmMgKCkgPT4ge1xuICAgICAgdHJ5IHtcbiAgICAgICAgY29uc3QgeyBkYXRhOiB7IHVzZXIgfSwgZXJyb3I6IHVzZXJFcnJvciB9ID0gYXdhaXQgc3VwYWJhc2UuYXV0aC5nZXRVc2VyKClcbiAgICAgICAgXG4gICAgICAgIGlmICh1c2VyRXJyb3IpIHtcbiAgICAgICAgICBjb25zb2xlLmVycm9yKCdFcnJvciBhbCBvYnRlbmVyIHVzdWFyaW86JywgdXNlckVycm9yKVxuICAgICAgICAgIHRocm93IHVzZXJFcnJvclxuICAgICAgICB9XG4gICAgICAgIFxuICAgICAgICBpZiAoIXVzZXIpIHtcbiAgICAgICAgICBjb25zb2xlLmxvZygnTm8gaGF5IHVzdWFyaW8gYXV0ZW50aWNhZG8nKVxuICAgICAgICAgIHJldHVyblxuICAgICAgICB9XG5cbiAgICAgICAgY29uc29sZS5sb2coJ1VzdWFyaW8gYXV0ZW50aWNhZG86JywgdXNlci5pZClcblxuICAgICAgICBjb25zdCB7IGRhdGE6IHRyYW5zYWN0aW9uc0RhdGEsIGVycm9yOiB0cmFuc2FjdGlvbnNFcnJvciB9ID0gYXdhaXQgc3VwYWJhc2VcbiAgICAgICAgICAuZnJvbSgnZXhwZW5zZXMnKVxuICAgICAgICAgIC5zZWxlY3QoJyonKVxuICAgICAgICAgIC5lcSgndXNlcl9pZCcsIHVzZXIuaWQpXG4gICAgICAgICAgLm9yZGVyKCdjcmVhdGVkX2F0JywgeyBhc2NlbmRpbmc6IGZhbHNlIH0pXG5cbiAgICAgICAgaWYgKHRyYW5zYWN0aW9uc0Vycm9yKSB7XG4gICAgICAgICAgY29uc29sZS5lcnJvcignRXJyb3IgYWwgY2FyZ2FyIHRyYW5zYWNjaW9uZXM6JywgdHJhbnNhY3Rpb25zRXJyb3IpXG4gICAgICAgICAgdGhyb3cgdHJhbnNhY3Rpb25zRXJyb3JcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnNvbGUubG9nKCdUcmFuc2FjY2lvbmVzIGNhcmdhZGFzOicsIHRyYW5zYWN0aW9uc0RhdGEpXG4gICAgICAgIHNldFRyYW5zYWN0aW9ucyh0cmFuc2FjdGlvbnNEYXRhIHx8IFtdKVxuXG4gICAgICAgIGNvbnN0IHsgZGF0YTogZG9sbGFyVmFsdWVzRGF0YSwgZXJyb3I6IGRvbGxhclZhbHVlc0Vycm9yIH0gPSBhd2FpdCBzdXBhYmFzZVxuICAgICAgICAgIC5mcm9tKCdkb2xsYXJfdmFsdWVzJylcbiAgICAgICAgICAuc2VsZWN0KCcqJylcbiAgICAgICAgICAub3JkZXIoJ21vbnRoJywgeyBhc2NlbmRpbmc6IGZhbHNlIH0pXG5cbiAgICAgICAgaWYgKGRvbGxhclZhbHVlc0Vycm9yKSB7XG4gICAgICAgICAgY29uc29sZS5lcnJvcignRXJyb3IgYWwgY2FyZ2FyIHZhbG9yZXMgZGVsIGTDs2xhcjonLCBkb2xsYXJWYWx1ZXNFcnJvcilcbiAgICAgICAgICB0aHJvdyBkb2xsYXJWYWx1ZXNFcnJvclxuICAgICAgICB9XG5cbiAgICAgICAgY29uc29sZS5sb2coJ1ZhbG9yZXMgZGVsIGTDs2xhciBjYXJnYWRvczonLCBkb2xsYXJWYWx1ZXNEYXRhKVxuICAgICAgICBzZXREb2xsYXJWYWx1ZXMoZG9sbGFyVmFsdWVzRGF0YSB8fCBbXSlcbiAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoJ0Vycm9yIGFsIGNhcmdhciBkYXRvczonLCBlcnJvcilcbiAgICAgICAgdG9hc3Qoe1xuICAgICAgICAgIHRpdGxlOiAnRXJyb3IgYWwgY2FyZ2FyIGxvcyBkYXRvcycsXG4gICAgICAgICAgZGVzY3JpcHRpb246IGVycm9yIGluc3RhbmNlb2YgRXJyb3IgPyBlcnJvci5tZXNzYWdlIDogJ0Vycm9yIGRlc2Nvbm9jaWRvJyxcbiAgICAgICAgICB2YXJpYW50OiAnZGVzdHJ1Y3RpdmUnXG4gICAgICAgIH0pXG4gICAgICB9XG4gICAgfVxuXG4gICAgbG9hZERhdGEoKVxuICB9LCBbc3VwYWJhc2VdKVxuXG4gIC8vIEd1YXJkYXIgdHJhbnNhY2Npb25lcyB5IHZhbG9yZXMgZGVsIGTDs2xhciBlbiBsb2NhbFN0b3JhZ2UgY3VhbmRvIGNhbWJpYW5cbiAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICBsb2NhbFN0b3JhZ2Uuc2V0SXRlbShgdHJhbnNhY3Rpb25zLSR7c3RvcmFnZUlkfWAsIEpTT04uc3RyaW5naWZ5KHRyYW5zYWN0aW9ucykpXG4gIH0sIFt0cmFuc2FjdGlvbnMsIHN0b3JhZ2VJZF0pXG5cbiAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICBsb2NhbFN0b3JhZ2Uuc2V0SXRlbShgZG9sbGFyLXZhbHVlcy0ke3N0b3JhZ2VJZH1gLCBKU09OLnN0cmluZ2lmeShkb2xsYXJWYWx1ZXMpKVxuICB9LCBbZG9sbGFyVmFsdWVzLCBzdG9yYWdlSWRdKVxuXG4gIC8vIEFncmVnYXIgdW5hIG51ZXZhIHRyYW5zYWNjacOzblxuICBjb25zdCBhZGRUcmFuc2FjdGlvbiA9IGFzeW5jICh0cmFuc2FjdGlvbjogT21pdDxUcmFuc2FjdGlvbiwgXCJpZFwiIHwgXCJjcmVhdGVkX2F0XCIgfCBcInVwZGF0ZWRfYXRcIiB8IFwidXNlcl9pZFwiPikgPT4ge1xuICAgIGlmICghc3VwYWJhc2UpIHJldHVyblxuXG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IHsgZGF0YTogeyB1c2VyIH0gfSA9IGF3YWl0IHN1cGFiYXNlLmF1dGguZ2V0VXNlcigpXG4gICAgICBpZiAoIXVzZXIpIHtcbiAgICAgICAgY29uc29sZS5lcnJvcignTm8gc2UgcHVkbyBvYnRlbmVyIGVsIHVzdWFyaW8gYXV0ZW50aWNhZG8nKVxuICAgICAgICByZXR1cm5cbiAgICAgIH1cblxuICAgICAgY29uc3QgZXhwZW5zZVRvSW5zZXJ0ID0ge1xuICAgICAgICBhbW91bnQ6IHRyYW5zYWN0aW9uLmFtb3VudCxcbiAgICAgICAgZGVzY3JpcHRpb246IHRyYW5zYWN0aW9uLmRlc2NyaXB0aW9uLFxuICAgICAgICBkYXRlOiB0cmFuc2FjdGlvbi5kYXRlLFxuICAgICAgICBjYXRlZ29yeV9pZDogdHJhbnNhY3Rpb24uY2F0ZWdvcnlfaWQsXG4gICAgICAgIHVzZXJfaWQ6IHVzZXIuaWQsXG4gICAgICAgIHR5cGU6IHRyYW5zYWN0aW9uLnR5cGUsXG4gICAgICB9XG5cbiAgICAgIGNvbnNvbGUubG9nKCdJbnNlcnRhbmRvIGVuIFN1cGFiYXNlOicsIGV4cGVuc2VUb0luc2VydClcblxuICAgICAgY29uc3QgeyBkYXRhLCBlcnJvciB9ID0gYXdhaXQgc3VwYWJhc2VcbiAgICAgICAgLmZyb20oJ2V4cGVuc2VzJylcbiAgICAgICAgLmluc2VydChbZXhwZW5zZVRvSW5zZXJ0XSlcbiAgICAgICAgLnNlbGVjdCgpXG4gICAgICAgIC5zaW5nbGUoKVxuXG4gICAgICBjb25zb2xlLmxvZygnUmVzcHVlc3RhIGRlIFN1cGFiYXNlOicsIHsgZGF0YSwgZXJyb3IgfSlcblxuICAgICAgaWYgKGVycm9yKSB0aHJvdyBlcnJvclxuXG4gICAgICAvLyBSZWNhcmdhciB0b2RhcyBsYXMgdHJhbnNhY2Npb25lcyBwYXJhIGFzZWd1cmFyIGNvbnNpc3RlbmNpYVxuICAgICAgY29uc3QgeyBkYXRhOiB0cmFuc2FjdGlvbnNEYXRhLCBlcnJvcjogdHJhbnNhY3Rpb25zRXJyb3IgfSA9IGF3YWl0IHN1cGFiYXNlXG4gICAgICAgIC5mcm9tKCdleHBlbnNlcycpXG4gICAgICAgIC5zZWxlY3QoJyonKVxuICAgICAgICAuZXEoJ3VzZXJfaWQnLCB1c2VyLmlkKVxuICAgICAgICAub3JkZXIoJ2NyZWF0ZWRfYXQnLCB7IGFzY2VuZGluZzogZmFsc2UgfSlcblxuICAgICAgaWYgKHRyYW5zYWN0aW9uc0Vycm9yKSB0aHJvdyB0cmFuc2FjdGlvbnNFcnJvclxuXG4gICAgICBjb25zb2xlLmxvZygnVHJhbnNhY2Npb25lcyBhY3R1YWxpemFkYXM6JywgdHJhbnNhY3Rpb25zRGF0YSlcbiAgICAgIHNldFRyYW5zYWN0aW9ucyh0cmFuc2FjdGlvbnNEYXRhIHx8IFtdKVxuICAgICAgdG9hc3QoeyB0aXRsZTogJ1RyYW5zYWNjacOzbiBhZ3JlZ2FkYSBjb3JyZWN0YW1lbnRlJyB9KVxuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBjb25zb2xlLmVycm9yKCdFcnJvciBhbCBhZ3JlZ2FyIHRyYW5zYWNjacOzbjonLCBlcnJvcilcbiAgICAgIHRvYXN0KHsgdGl0bGU6ICdFcnJvciBhbCBhZ3JlZ2FyIGxhIHRyYW5zYWNjacOzbicgfSlcbiAgICAgIHRocm93IGVycm9yXG4gICAgfVxuICB9XG5cbiAgLy8gQWN0dWFsaXphciB1bmEgdHJhbnNhY2Npw7NuIGV4aXN0ZW50ZVxuICBjb25zdCB1cGRhdGVUcmFuc2FjdGlvbiA9IGFzeW5jIChpZDogc3RyaW5nLCB0cmFuc2FjdGlvbjogUGFydGlhbDxUcmFuc2FjdGlvbj4pID0+IHtcbiAgICBpZiAoIXN1cGFiYXNlKSByZXR1cm5cblxuICAgIHRyeSB7XG4gICAgICAvLyBBZGFwdGFyIGxvcyBjYW1wb3MgYWwgZXNxdWVtYSBkZSBleHBlbnNlc1xuICAgICAgY29uc3QgZXhwZW5zZVRvVXBkYXRlOiBhbnkgPSB7fVxuICAgICAgaWYgKHRyYW5zYWN0aW9uLmFtb3VudCAhPT0gdW5kZWZpbmVkKSBleHBlbnNlVG9VcGRhdGUuYW1vdW50ID0gdHJhbnNhY3Rpb24uYW1vdW50XG4gICAgICBpZiAodHJhbnNhY3Rpb24uZGVzY3JpcHRpb24gIT09IHVuZGVmaW5lZCkgZXhwZW5zZVRvVXBkYXRlLmRlc2NyaXB0aW9uID0gdHJhbnNhY3Rpb24uZGVzY3JpcHRpb25cbiAgICAgIGlmICh0cmFuc2FjdGlvbi5kYXRlICE9PSB1bmRlZmluZWQpIGV4cGVuc2VUb1VwZGF0ZS5kYXRlID0gdHJhbnNhY3Rpb24uZGF0ZVxuICAgICAgaWYgKHRyYW5zYWN0aW9uLmNhdGVnb3J5X2lkICE9PSB1bmRlZmluZWQpIGV4cGVuc2VUb1VwZGF0ZS5jYXRlZ29yeV9pZCA9IHRyYW5zYWN0aW9uLmNhdGVnb3J5X2lkXG4gICAgICBpZiAodHJhbnNhY3Rpb24udHlwZSAhPT0gdW5kZWZpbmVkKSBleHBlbnNlVG9VcGRhdGUudHlwZSA9IHRyYW5zYWN0aW9uLnR5cGVcblxuICAgICAgY29uc29sZS5sb2coJ0FjdHVhbGl6YW5kbyB0cmFuc2FjY2nDs246JywgeyBpZCwgLi4uZXhwZW5zZVRvVXBkYXRlIH0pXG5cbiAgICAgIGNvbnN0IHsgZGF0YSwgZXJyb3IgfSA9IGF3YWl0IHN1cGFiYXNlXG4gICAgICAgIC5mcm9tKCdleHBlbnNlcycpXG4gICAgICAgIC51cGRhdGUoZXhwZW5zZVRvVXBkYXRlKVxuICAgICAgICAuZXEoJ2lkJywgaWQpXG4gICAgICAgIC5zZWxlY3QoKVxuICAgICAgICAuc2luZ2xlKClcblxuICAgICAgaWYgKGVycm9yKSB0aHJvdyBlcnJvclxuXG4gICAgICBjb25zb2xlLmxvZygnVHJhbnNhY2Npw7NuIGFjdHVhbGl6YWRhOicsIGRhdGEpXG5cbiAgICAgIC8vIFJlY2FyZ2FyIHRvZGFzIGxhcyB0cmFuc2FjY2lvbmVzIHBhcmEgYXNlZ3VyYXIgY29uc2lzdGVuY2lhXG4gICAgICBjb25zdCB7IGRhdGE6IHRyYW5zYWN0aW9uc0RhdGEsIGVycm9yOiB0cmFuc2FjdGlvbnNFcnJvciB9ID0gYXdhaXQgc3VwYWJhc2VcbiAgICAgICAgLmZyb20oJ2V4cGVuc2VzJylcbiAgICAgICAgLnNlbGVjdCgnKicpXG4gICAgICAgIC5vcmRlcignY3JlYXRlZF9hdCcsIHsgYXNjZW5kaW5nOiBmYWxzZSB9KVxuXG4gICAgICBpZiAodHJhbnNhY3Rpb25zRXJyb3IpIHRocm93IHRyYW5zYWN0aW9uc0Vycm9yXG5cbiAgICAgIGNvbnNvbGUubG9nKCdUcmFuc2FjY2lvbmVzIGFjdHVhbGl6YWRhczonLCB0cmFuc2FjdGlvbnNEYXRhKVxuICAgICAgc2V0VHJhbnNhY3Rpb25zKHRyYW5zYWN0aW9uc0RhdGEgfHwgW10pXG4gICAgICB0b2FzdCh7IHRpdGxlOiAnVHJhbnNhY2Npw7NuIGFjdHVhbGl6YWRhIGNvcnJlY3RhbWVudGUnIH0pXG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoJ0Vycm9yIGFsIGFjdHVhbGl6YXIgdHJhbnNhY2Npw7NuOicsIGVycm9yKVxuICAgICAgdG9hc3QoeyB0aXRsZTogJ0Vycm9yIGFsIGFjdHVhbGl6YXIgbGEgdHJhbnNhY2Npw7NuJyB9KVxuICAgICAgdGhyb3cgZXJyb3JcbiAgICB9XG4gIH1cblxuICAvLyBFbGltaW5hciB1bmEgdHJhbnNhY2Npw7NuXG4gIGNvbnN0IGRlbGV0ZVRyYW5zYWN0aW9uID0gYXN5bmMgKGlkOiBzdHJpbmcpID0+IHtcbiAgICBpZiAoIXN1cGFiYXNlKSByZXR1cm5cblxuICAgIHRyeSB7XG4gICAgICBjb25zb2xlLmxvZygnRWxpbWluYW5kbyB0cmFuc2FjY2nDs246JywgaWQpXG5cbiAgICAgIGNvbnN0IHsgZXJyb3IgfSA9IGF3YWl0IHN1cGFiYXNlLmZyb20oJ2V4cGVuc2VzJykuZGVsZXRlKCkuZXEoJ2lkJywgaWQpXG5cbiAgICAgIGlmIChlcnJvcikgdGhyb3cgZXJyb3JcblxuICAgICAgLy8gUmVjYXJnYXIgdG9kYXMgbGFzIHRyYW5zYWNjaW9uZXMgcGFyYSBhc2VndXJhciBjb25zaXN0ZW5jaWFcbiAgICAgIGNvbnN0IHsgZGF0YTogdHJhbnNhY3Rpb25zRGF0YSwgZXJyb3I6IHRyYW5zYWN0aW9uc0Vycm9yIH0gPSBhd2FpdCBzdXBhYmFzZVxuICAgICAgICAuZnJvbSgnZXhwZW5zZXMnKVxuICAgICAgICAuc2VsZWN0KCcqJylcbiAgICAgICAgLm9yZGVyKCdjcmVhdGVkX2F0JywgeyBhc2NlbmRpbmc6IGZhbHNlIH0pXG5cbiAgICAgIGlmICh0cmFuc2FjdGlvbnNFcnJvcikgdGhyb3cgdHJhbnNhY3Rpb25zRXJyb3JcblxuICAgICAgY29uc29sZS5sb2coJ1RyYW5zYWNjaW9uZXMgYWN0dWFsaXphZGFzOicsIHRyYW5zYWN0aW9uc0RhdGEpXG4gICAgICBzZXRUcmFuc2FjdGlvbnModHJhbnNhY3Rpb25zRGF0YSB8fCBbXSlcbiAgICAgIHRvYXN0KHsgdGl0bGU6ICdUcmFuc2FjY2nDs24gZWxpbWluYWRhIGNvcnJlY3RhbWVudGUnIH0pXG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoJ0Vycm9yIGFsIGVsaW1pbmFyIHRyYW5zYWNjacOzbjonLCBlcnJvcilcbiAgICAgIHRvYXN0KHsgdGl0bGU6ICdFcnJvciBhbCBlbGltaW5hciBsYSB0cmFuc2FjY2nDs24nIH0pXG4gICAgICB0aHJvdyBlcnJvclxuICAgIH1cbiAgfVxuXG4gIC8vIE9idGVuZXIgdHJhbnNhY2Npb25lcyBkZSB1biBtZXMgZXNwZWPDrWZpY29cbiAgY29uc3QgZ2V0TW9udGhUcmFuc2FjdGlvbnMgPSAobW9udGg6IHN0cmluZykgPT4ge1xuICAgIHJldHVybiB0cmFuc2FjdGlvbnMuZmlsdGVyKCh0KSA9PiB0LmRhdGUuc3RhcnRzV2l0aChtb250aCkpXG4gIH1cblxuICAvLyBPYnRlbmVyIHJlc3VtZW4gZGUgdW4gbWVzIGVzcGVjw61maWNvXG4gIGNvbnN0IGdldE1vbnRoU3VtbWFyeSA9IChtb250aDogc3RyaW5nKTogTW9udGhTdW1tYXJ5ID0+IHtcbiAgICBjb25zdCBtb250aFRyYW5zYWN0aW9ucyA9IGdldE1vbnRoVHJhbnNhY3Rpb25zKG1vbnRoKVxuICAgIGNvbnN0IGluY29tZSA9IG1vbnRoVHJhbnNhY3Rpb25zXG4gICAgICAuZmlsdGVyKCh0KSA9PiB0LnR5cGUgPT09ICdpbmdyZXNvJylcbiAgICAgIC5yZWR1Y2UoKHN1bSwgdCkgPT4gc3VtICsgdC5hbW91bnQsIDApXG4gICAgY29uc3QgZXhwZW5zZSA9IG1vbnRoVHJhbnNhY3Rpb25zXG4gICAgICAuZmlsdGVyKCh0KSA9PiB0LnR5cGUgPT09ICdnYXN0bycpXG4gICAgICAucmVkdWNlKChzdW0sIHQpID0+IHN1bSArIHQuYW1vdW50LCAwKVxuXG4gICAgcmV0dXJuIHtcbiAgICAgIG1vbnRoLFxuICAgICAgaW5jb21lLFxuICAgICAgZXhwZW5zZSxcbiAgICAgIGJhbGFuY2U6IGluY29tZSAtIGV4cGVuc2UsXG4gICAgfVxuICB9XG5cbiAgLy8gT2J0ZW5lciByZXN1bWVuIHBvciBjYXRlZ29yw61hIHBhcmEgdW4gbWVzIGVzcGVjw61maWNvXG4gIGNvbnN0IGdldE1vbnRoQ2F0ZWdvcnlTdW1tYXJ5ID0gKG1vbnRoOiBzdHJpbmcsIHR5cGU6ICdpbmdyZXNvJyB8ICdnYXN0bycpID0+IHtcbiAgICBjb25zdCBtb250aFRyYW5zYWN0aW9ucyA9IGdldE1vbnRoVHJhbnNhY3Rpb25zKG1vbnRoKS5maWx0ZXIoKHQpID0+IHQudHlwZSA9PT0gdHlwZSlcbiAgICBjb25zdCBjYXRlZ29yeVN1bW1hcnk6IFJlY29yZDxzdHJpbmcsIG51bWJlcj4gPSB7fVxuXG4gICAgbW9udGhUcmFuc2FjdGlvbnMuZm9yRWFjaCgodHJhbnNhY3Rpb24pID0+IHtcbiAgICAgIGlmICghY2F0ZWdvcnlTdW1tYXJ5W3RyYW5zYWN0aW9uLmNhdGVnb3J5X2lkXSkge1xuICAgICAgICBjYXRlZ29yeVN1bW1hcnlbdHJhbnNhY3Rpb24uY2F0ZWdvcnlfaWRdID0gMFxuICAgICAgfVxuICAgICAgY2F0ZWdvcnlTdW1tYXJ5W3RyYW5zYWN0aW9uLmNhdGVnb3J5X2lkXSArPSB0cmFuc2FjdGlvbi5hbW91bnRcbiAgICB9KVxuXG4gICAgcmV0dXJuIE9iamVjdC5lbnRyaWVzKGNhdGVnb3J5U3VtbWFyeSlcbiAgICAgIC5tYXAoKFtjYXRlZ29yeSwgYW1vdW50XSkgPT4gKHtcbiAgICAgICAgY2F0ZWdvcnksXG4gICAgICAgIGFtb3VudCxcbiAgICAgIH0pKVxuICAgICAgLnNvcnQoKGEsIGIpID0+IGIuYW1vdW50IC0gYS5hbW91bnQpXG4gIH1cblxuICAvLyBPYnRlbmVyIGxvcyDDumx0aW1vcyA2IG1lc2VzIHBhcmEgZWwgZ3LDoWZpY28gZGUgYmFycmFzXG4gIGNvbnN0IGdldExhc3RTaXhNb250aHNTdW1tYXJ5ID0gKCk6IE1vbnRoU3VtbWFyeVtdID0+IHtcbiAgICBjb25zdCB0b2RheSA9IG5ldyBEYXRlKClcbiAgICBjb25zdCBtb250aHM6IHN0cmluZ1tdID0gW11cblxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgNjsgaSsrKSB7XG4gICAgICBjb25zdCBkID0gbmV3IERhdGUodG9kYXkuZ2V0RnVsbFllYXIoKSwgdG9kYXkuZ2V0TW9udGgoKSAtIGksIDEpXG4gICAgICBjb25zdCBtb250aCA9IGAke2QuZ2V0RnVsbFllYXIoKX0tJHtTdHJpbmcoZC5nZXRNb250aCgpICsgMSkucGFkU3RhcnQoMiwgJzAnKX1gXG4gICAgICBtb250aHMucHVzaChtb250aClcbiAgICB9XG5cbiAgICByZXR1cm4gbW9udGhzLm1hcCgobW9udGgpID0+IGdldE1vbnRoU3VtbWFyeShtb250aCkpLnJldmVyc2UoKVxuICB9XG5cbiAgLy8gT2J0ZW5lciB0b2RvcyBsb3MgbWVzZXMgZGVsIGHDsW8gYWN0dWFsIHBhcmEgZWwgZ3LDoWZpY28gZGUgbMOtbmVhc1xuICBjb25zdCBnZXRBbGxNb250aHNTdW1tYXJ5ID0gKCk6IE1vbnRoU3VtbWFyeVtdID0+IHtcbiAgICBjb25zdCBjdXJyZW50WWVhciA9IG5ldyBEYXRlKCkuZ2V0RnVsbFllYXIoKVxuICAgIGNvbnN0IG1vbnRoczogc3RyaW5nW10gPSBbXVxuXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCAxMjsgaSsrKSB7XG4gICAgICBjb25zdCBtb250aCA9IGAke2N1cnJlbnRZZWFyfS0ke1N0cmluZyhpICsgMSkucGFkU3RhcnQoMiwgJzAnKX1gXG4gICAgICBtb250aHMucHVzaChtb250aClcbiAgICB9XG5cbiAgICByZXR1cm4gbW9udGhzLm1hcCgobW9udGgpID0+IGdldE1vbnRoU3VtbWFyeShtb250aCkpXG4gIH1cblxuICAvLyBPYnRlbmVyIGVsIHZhbG9yIGRlbCBkw7NsYXIgcGFyYSB1biBtZXMgZXNwZWPDrWZpY29cbiAgY29uc3QgZ2V0RG9sbGFyVmFsdWUgPSAobW9udGg6IHN0cmluZyk6IERvbGxhclZhbHVlIHwgdW5kZWZpbmVkID0+IHtcbiAgICByZXR1cm4gZG9sbGFyVmFsdWVzLmZpbmQoKGQpID0+IGQubW9udGggPT09IG1vbnRoKVxuICB9XG5cbiAgLy8gQWN0dWFsaXphciBlbCB2YWxvciBkZWwgZMOzbGFyIHBhcmEgdW4gbWVzIGVzcGVjw61maWNvXG4gIGNvbnN0IHVwZGF0ZURvbGxhclZhbHVlID0gYXN5bmMgKG1vbnRoOiBzdHJpbmcsIHZhbHVlOiBudW1iZXIpID0+IHtcbiAgICBpZiAoIXN1cGFiYXNlKSByZXR1cm5cblxuICAgIHRyeSB7XG4gICAgICBjb25zdCB7IGRhdGE6IHsgdXNlciB9IH0gPSBhd2FpdCBzdXBhYmFzZS5hdXRoLmdldFVzZXIoKVxuICAgICAgaWYgKCF1c2VyKSB7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoJ05vIHNlIHB1ZG8gb2J0ZW5lciBlbCB1c3VhcmlvIGF1dGVudGljYWRvJylcbiAgICAgICAgcmV0dXJuXG4gICAgICB9XG4gICAgICBjb25zdCBleGlzdGluZ0RvbGxhciA9IGRvbGxhclZhbHVlcy5maW5kKChkKSA9PiBkLm1vbnRoID09PSBtb250aClcbiAgICAgIGNvbnN0IGRvbGxhclZhbHVlID0ge1xuICAgICAgICBpZDogZXhpc3RpbmdEb2xsYXI/LmlkLFxuICAgICAgICBtb250aCxcbiAgICAgICAgdmFsdWUsXG4gICAgICAgIHVzZXJfaWQ6IHVzZXIuaWQsXG4gICAgICAgIHVwZGF0ZWRfYXQ6IG5ldyBEYXRlKCkudG9JU09TdHJpbmcoKSxcbiAgICAgIH1cblxuICAgICAgY29uc3QgeyBkYXRhLCBlcnJvciB9ID0gYXdhaXQgc3VwYWJhc2VcbiAgICAgICAgLmZyb20oJ2RvbGxhcl92YWx1ZXMnKVxuICAgICAgICAudXBzZXJ0KGRvbGxhclZhbHVlLCB7IG9uQ29uZmxpY3Q6ICdtb250aCcgfSlcbiAgICAgICAgLnNlbGVjdCgpXG4gICAgICAgIC5zaW5nbGUoKVxuXG4gICAgICBpZiAoZXJyb3IpIHRocm93IGVycm9yXG5cbiAgICAgIHNldERvbGxhclZhbHVlcygocHJldikgPT4ge1xuICAgICAgICBjb25zdCBleGlzdGluZ0luZGV4ID0gcHJldi5maW5kSW5kZXgoKGQpID0+IGQubW9udGggPT09IG1vbnRoKVxuICAgICAgICBpZiAoZXhpc3RpbmdJbmRleCA+PSAwKSB7XG4gICAgICAgICAgcmV0dXJuIHByZXYubWFwKChkKSA9PiAoZC5tb250aCA9PT0gbW9udGggPyBkYXRhIDogZCkpXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmV0dXJuIFsuLi5wcmV2LCBkYXRhXVxuICAgICAgICB9XG4gICAgICB9KVxuXG4gICAgICB0b2FzdCh7IHRpdGxlOiAnVmFsb3IgZGVsIGTDs2xhciBhY3R1YWxpemFkbyBjb3JyZWN0YW1lbnRlJyB9KVxuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBjb25zb2xlLmVycm9yKCdFcnJvciBhbCBhY3R1YWxpemFyIHZhbG9yIGRlbCBkw7NsYXI6JywgZXJyb3IpXG4gICAgICB0b2FzdCh7IHRpdGxlOiAnRXJyb3IgYWwgYWN0dWFsaXphciBlbCB2YWxvciBkZWwgZMOzbGFyJyB9KVxuICAgICAgdGhyb3cgZXJyb3JcbiAgICB9XG4gIH1cblxuICByZXR1cm4gKFxuICAgIDxUcmFuc2FjdGlvbkNvbnRleHQuUHJvdmlkZXJcbiAgICAgIHZhbHVlPXt7XG4gICAgICAgIHRyYW5zYWN0aW9ucyxcbiAgICAgICAgZG9sbGFyVmFsdWVzLFxuICAgICAgICBhZGRUcmFuc2FjdGlvbixcbiAgICAgICAgdXBkYXRlVHJhbnNhY3Rpb24sXG4gICAgICAgIGRlbGV0ZVRyYW5zYWN0aW9uLFxuICAgICAgICBnZXRNb250aFRyYW5zYWN0aW9ucyxcbiAgICAgICAgZ2V0TW9udGhTdW1tYXJ5LFxuICAgICAgICBnZXRMYXN0U2l4TW9udGhzU3VtbWFyeSxcbiAgICAgICAgZ2V0QWxsTW9udGhzU3VtbWFyeSxcbiAgICAgICAgZ2V0RG9sbGFyVmFsdWUsXG4gICAgICAgIHVwZGF0ZURvbGxhclZhbHVlLFxuICAgICAgICBnZXRNb250aENhdGVnb3J5U3VtbWFyeSxcbiAgICAgIH19XG4gICAgPlxuICAgICAge2NoaWxkcmVufVxuICAgIDwvVHJhbnNhY3Rpb25Db250ZXh0LlByb3ZpZGVyPlxuICApXG59XG5cbmV4cG9ydCBmdW5jdGlvbiB1c2VUcmFuc2FjdGlvbnMoKSB7XG4gIGNvbnN0IGNvbnRleHQgPSB1c2VDb250ZXh0KFRyYW5zYWN0aW9uQ29udGV4dClcbiAgaWYgKGNvbnRleHQgPT09IHVuZGVmaW5lZCkge1xuICAgIHRocm93IG5ldyBFcnJvcihcInVzZVRyYW5zYWN0aW9ucyBtdXN0IGJlIHVzZWQgd2l0aGluIGEgVHJhbnNhY3Rpb25Qcm92aWRlclwiKVxuICB9XG4gIHJldHVybiBjb250ZXh0XG59XG4iXSwibmFtZXMiOlsiY3JlYXRlQ29udGV4dCIsInVzZUNvbnRleHQiLCJ1c2VFZmZlY3QiLCJ1c2VTdGF0ZSIsInVzZUlkIiwidXNlT3B0aW1pc3RpYyIsInVzZVRvYXN0IiwidXNlU3VwYWJhc2UiLCJUcmFuc2FjdGlvbkNvbnRleHQiLCJ1bmRlZmluZWQiLCJUcmFuc2FjdGlvblByb3ZpZGVyIiwiY2hpbGRyZW4iLCJzdXBhYmFzZSIsInRyYW5zYWN0aW9ucyIsInNldFRyYW5zYWN0aW9ucyIsImRvbGxhclZhbHVlcyIsInNldERvbGxhclZhbHVlcyIsIm9wdGltaXN0aWNUcmFuc2FjdGlvbnMiLCJhZGRPcHRpbWlzdGljVHJhbnNhY3Rpb24iLCJzdGF0ZSIsImFjdGlvbiIsImRhdGEiLCJtYXAiLCJ0IiwiaWQiLCJ0cmFuc2FjdGlvbiIsImZpbHRlciIsIm9wdGltaXN0aWNEb2xsYXJWYWx1ZXMiLCJhZGRPcHRpbWlzdGljRG9sbGFyVmFsdWUiLCJleGlzdGluZ0luZGV4IiwiZmluZEluZGV4IiwiZCIsIm1vbnRoIiwidG9hc3QiLCJzdG9yYWdlSWQiLCJsb2FkRGF0YSIsInVzZXIiLCJlcnJvciIsInVzZXJFcnJvciIsImF1dGgiLCJnZXRVc2VyIiwiY29uc29sZSIsImxvZyIsInRyYW5zYWN0aW9uc0RhdGEiLCJ0cmFuc2FjdGlvbnNFcnJvciIsImZyb20iLCJzZWxlY3QiLCJlcSIsIm9yZGVyIiwiYXNjZW5kaW5nIiwiZG9sbGFyVmFsdWVzRGF0YSIsImRvbGxhclZhbHVlc0Vycm9yIiwidGl0bGUiLCJkZXNjcmlwdGlvbiIsIkVycm9yIiwibWVzc2FnZSIsInZhcmlhbnQiLCJsb2NhbFN0b3JhZ2UiLCJzZXRJdGVtIiwiSlNPTiIsInN0cmluZ2lmeSIsImFkZFRyYW5zYWN0aW9uIiwiZXhwZW5zZVRvSW5zZXJ0IiwiYW1vdW50IiwiZGF0ZSIsImNhdGVnb3J5X2lkIiwidXNlcl9pZCIsInR5cGUiLCJpbnNlcnQiLCJzaW5nbGUiLCJ1cGRhdGVUcmFuc2FjdGlvbiIsImV4cGVuc2VUb1VwZGF0ZSIsInVwZGF0ZSIsImRlbGV0ZVRyYW5zYWN0aW9uIiwiZGVsZXRlIiwiZ2V0TW9udGhUcmFuc2FjdGlvbnMiLCJzdGFydHNXaXRoIiwiZ2V0TW9udGhTdW1tYXJ5IiwibW9udGhUcmFuc2FjdGlvbnMiLCJpbmNvbWUiLCJyZWR1Y2UiLCJzdW0iLCJleHBlbnNlIiwiYmFsYW5jZSIsImdldE1vbnRoQ2F0ZWdvcnlTdW1tYXJ5IiwiY2F0ZWdvcnlTdW1tYXJ5IiwiZm9yRWFjaCIsIk9iamVjdCIsImVudHJpZXMiLCJjYXRlZ29yeSIsInNvcnQiLCJhIiwiYiIsImdldExhc3RTaXhNb250aHNTdW1tYXJ5IiwidG9kYXkiLCJEYXRlIiwibW9udGhzIiwiaSIsImdldEZ1bGxZZWFyIiwiZ2V0TW9udGgiLCJTdHJpbmciLCJwYWRTdGFydCIsInB1c2giLCJyZXZlcnNlIiwiZ2V0QWxsTW9udGhzU3VtbWFyeSIsImN1cnJlbnRZZWFyIiwiZ2V0RG9sbGFyVmFsdWUiLCJmaW5kIiwidXBkYXRlRG9sbGFyVmFsdWUiLCJ2YWx1ZSIsImV4aXN0aW5nRG9sbGFyIiwiZG9sbGFyVmFsdWUiLCJ1cGRhdGVkX2F0IiwidG9JU09TdHJpbmciLCJ1cHNlcnQiLCJvbkNvbmZsaWN0IiwicHJldiIsIlByb3ZpZGVyIiwidXNlVHJhbnNhY3Rpb25zIiwiY29udGV4dCJdLCJpZ25vcmVMaXN0IjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./context/transaction-context.tsx\n"));

/***/ })

});