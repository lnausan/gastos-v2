"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/historial/page",{

/***/ "(app-pages-browser)/./context/transaction-context.tsx":
/*!*****************************************!*\
  !*** ./context/transaction-context.tsx ***!
  \*****************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   TransactionProvider: () => (/* binding */ TransactionProvider),\n/* harmony export */   useTransactions: () => (/* binding */ useTransactions)\n/* harmony export */ });\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-dev-runtime */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/jsx-dev-runtime.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var _components_ui_use_toast__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @/components/ui/use-toast */ \"(app-pages-browser)/./components/ui/use-toast.ts\");\n/* harmony import */ var _components_providers_supabase_provider__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @/components/providers/supabase-provider */ \"(app-pages-browser)/./components/providers/supabase-provider.tsx\");\n/* harmony import */ var _barrel_optimize_names_format_subMonths_date_fns__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! __barrel_optimize__?names=format,subMonths!=!date-fns */ \"(app-pages-browser)/./node_modules/date-fns/subMonths.mjs\");\n/* harmony import */ var _barrel_optimize_names_format_subMonths_date_fns__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! __barrel_optimize__?names=format,subMonths!=!date-fns */ \"(app-pages-browser)/./node_modules/date-fns/format.mjs\");\n/* __next_internal_client_entry_do_not_use__ TransactionProvider,useTransactions auto */ \nvar _s = $RefreshSig$(), _s1 = $RefreshSig$();\n\n\n\n\nconst TransactionContext = /*#__PURE__*/ (0,react__WEBPACK_IMPORTED_MODULE_1__.createContext)(undefined);\nfunction TransactionProvider(param) {\n    let { children } = param;\n    _s();\n    const { supabase } = (0,_components_providers_supabase_provider__WEBPACK_IMPORTED_MODULE_3__.useSupabase)();\n    const [transactions, setTransactions] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)([]);\n    const [dollarValues, setDollarValues] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)([]);\n    const [isLoading, setIsLoading] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(true);\n    const [optimisticTransactions, addOptimisticTransaction] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useOptimistic)(transactions, {\n        \"TransactionProvider.useOptimistic\": (state, param)=>{\n            let { action, data } = param;\n            if (action === \"add\") {\n                return [\n                    ...state,\n                    data\n                ];\n            } else if (action === \"update\") {\n                return state.map({\n                    \"TransactionProvider.useOptimistic\": (t)=>t.id === data.id ? {\n                            ...t,\n                            ...data.transaction\n                        } : t\n                }[\"TransactionProvider.useOptimistic\"]);\n            } else if (action === \"delete\") {\n                return state.filter({\n                    \"TransactionProvider.useOptimistic\": (t)=>t.id !== data.id\n                }[\"TransactionProvider.useOptimistic\"]);\n            }\n            return state;\n        }\n    }[\"TransactionProvider.useOptimistic\"]);\n    const [optimisticDollarValues, addOptimisticDollarValue] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useOptimistic)(dollarValues, {\n        \"TransactionProvider.useOptimistic\": (state, param)=>{\n            let { action, data } = param;\n            if (action === \"update\") {\n                const existingIndex = state.findIndex({\n                    \"TransactionProvider.useOptimistic.existingIndex\": (d)=>d.month === data.month\n                }[\"TransactionProvider.useOptimistic.existingIndex\"]);\n                if (existingIndex >= 0) {\n                    return state.map({\n                        \"TransactionProvider.useOptimistic\": (d)=>d.month === data.month ? data : d\n                    }[\"TransactionProvider.useOptimistic\"]);\n                } else {\n                    return [\n                        ...state,\n                        data\n                    ];\n                }\n            }\n            return state;\n        }\n    }[\"TransactionProvider.useOptimistic\"]);\n    const { toast } = (0,_components_ui_use_toast__WEBPACK_IMPORTED_MODULE_2__.useToast)();\n    const storageId = (0,react__WEBPACK_IMPORTED_MODULE_1__.useId)();\n    // Cargar transacciones y valores del dólar desde localStorage al iniciar\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)({\n        \"TransactionProvider.useEffect\": ()=>{\n            if (!supabase) return;\n            // 1. Cargar datos de localStorage primero\n            const cachedTransactions = localStorage.getItem(\"transactions-\".concat(storageId));\n            if (cachedTransactions) {\n                try {\n                    const parsedTransactions = JSON.parse(cachedTransactions);\n                    setTransactions(parsedTransactions);\n                    setIsLoading(false) // Ya tenemos datos, no mostrar loading\n                    ;\n                } catch (e) {\n                    console.error('Error al parsear transacciones del localStorage:', e);\n                }\n            }\n            const cachedDollarValues = localStorage.getItem(\"dollar-values-\".concat(storageId));\n            if (cachedDollarValues) {\n                try {\n                    setDollarValues(JSON.parse(cachedDollarValues));\n                } catch (e) {\n                    console.error('Error al parsear valores del dólar del localStorage:', e);\n                }\n            }\n            // 2. Luego cargar desde Supabase en segundo plano\n            const loadData = {\n                \"TransactionProvider.useEffect.loadData\": async ()=>{\n                    try {\n                        const { data: { user }, error: userError } = await supabase.auth.getUser();\n                        if (userError) {\n                            console.error('Error al obtener usuario:', userError);\n                            throw userError;\n                        }\n                        if (!user) {\n                            console.error('No hay usuario autenticado');\n                            return;\n                        }\n                        // Calcular los últimos 6 meses\n                        const today = new Date();\n                        const months = [];\n                        for(let i = 0; i < 6; i++){\n                            const d = (0,_barrel_optimize_names_format_subMonths_date_fns__WEBPACK_IMPORTED_MODULE_4__.subMonths)(today, i);\n                            months.push((0,_barrel_optimize_names_format_subMonths_date_fns__WEBPACK_IMPORTED_MODULE_5__.format)(d, \"yyyy-MM\"));\n                        }\n                        console.log('Buscando transacciones para los meses:', months);\n                        // Traer solo las transacciones de los últimos 6 meses\n                        const { data: transactionsData, error: transactionsError } = await supabase.from('expenses').select('*').eq('user_id', user.id).gte('date', \"\".concat(months[months.length - 1], \"-01\")).lte('date', \"\".concat(months[0], \"-31\")).order('created_at', {\n                            ascending: false\n                        });\n                        if (transactionsError) {\n                            console.error('Error al cargar transacciones:', transactionsError);\n                            throw transactionsError;\n                        }\n                        if (transactionsData) {\n                            console.log('Transacciones cargadas:', transactionsData.length);\n                            setTransactions(transactionsData);\n                            localStorage.setItem(\"transactions-\".concat(storageId), JSON.stringify(transactionsData));\n                        }\n                        console.log('Buscando valores del dólar para los meses:', months);\n                        // Traer todos los valores del dólar del usuario\n                        const loadDollarValues = {\n                            \"TransactionProvider.useEffect.loadData.loadDollarValues\": async ()=>{\n                                if (!supabase) {\n                                    console.error('Supabase no está inicializado');\n                                    return;\n                                }\n                                try {\n                                    // 1. Verificar autenticación\n                                    const { data: { user }, error: userError } = await supabase.auth.getUser();\n                                    if (userError) {\n                                        console.error('Error al obtener usuario:', userError);\n                                        return;\n                                    }\n                                    if (!user) {\n                                        console.error('No hay usuario autenticado');\n                                        return;\n                                    }\n                                    console.log('Cargando historial de valores del dólar para usuario:', user.id);\n                                    // 2. Cargar todos los valores históricos\n                                    const { data, error } = await supabase.from('dollar_values').select('*').eq('user_id', user.id).order('month', {\n                                        ascending: false\n                                    });\n                                    console.log('Respuesta de la carga de dólares:', {\n                                        data,\n                                        error\n                                    });\n                                    if (error) {\n                                        console.error('Error al cargar valores del dólar:', error);\n                                        return;\n                                    }\n                                    if (!data) {\n                                        console.log('No se encontraron valores del dólar');\n                                        setDollarValues([]);\n                                        localStorage.setItem(\"dollar-values-\".concat(storageId), JSON.stringify([]));\n                                        return;\n                                    }\n                                    console.log('Historial de valores del dólar cargados:', data);\n                                    setDollarValues(data);\n                                    localStorage.setItem(\"dollar-values-\".concat(storageId), JSON.stringify(data));\n                                } catch (error) {\n                                    console.error('Error inesperado al cargar valores del dólar:', error);\n                                    setDollarValues([]);\n                                    localStorage.setItem(\"dollar-values-\".concat(storageId), JSON.stringify([]));\n                                }\n                            }\n                        }[\"TransactionProvider.useEffect.loadData.loadDollarValues\"];\n                        // Ejecutar la carga de datos\n                        await loadDollarValues();\n                    } catch (error) {\n                        console.error('Error detallado al cargar datos:', error);\n                        // No mostrar el error al usuario si ya tenemos datos en localStorage\n                        if (transactions.length === 0) {\n                            toast({\n                                title: 'Error al cargar los datos',\n                                description: error instanceof Error ? error.message : 'Error desconocido',\n                                variant: 'destructive'\n                            });\n                        }\n                    } finally{\n                        setIsLoading(false);\n                    }\n                }\n            }[\"TransactionProvider.useEffect.loadData\"];\n            loadData();\n        }\n    }[\"TransactionProvider.useEffect\"], [\n        supabase\n    ]);\n    // Agregar una nueva transacción\n    const addTransaction = async (transaction)=>{\n        if (!supabase) return;\n        try {\n            const { data: { user } } = await supabase.auth.getUser();\n            if (!user) {\n                console.error('No se pudo obtener el usuario autenticado');\n                return;\n            }\n            const expenseToInsert = {\n                amount: transaction.amount,\n                description: transaction.description,\n                date: transaction.date,\n                category_id: transaction.category_id,\n                user_id: user.id,\n                type: transaction.type\n            };\n            console.log('Insertando en Supabase:', expenseToInsert);\n            const { data, error } = await supabase.from('expenses').insert([\n                expenseToInsert\n            ]).select().single();\n            console.log('Respuesta de Supabase:', {\n                data,\n                error\n            });\n            if (error) throw error;\n            // Recargar todas las transacciones para asegurar consistencia\n            const { data: transactionsData, error: transactionsError } = await supabase.from('expenses').select('*').eq('user_id', user.id).order('created_at', {\n                ascending: false\n            });\n            if (transactionsError) throw transactionsError;\n            console.log('Transacciones actualizadas:', transactionsData);\n            setTransactions(transactionsData || []);\n            toast({\n                title: 'Transacción agregada correctamente'\n            });\n        } catch (error) {\n            console.error('Error al agregar transacción:', error);\n            toast({\n                title: 'Error al agregar la transacción'\n            });\n            throw error;\n        }\n    };\n    // Actualizar una transacción existente\n    const updateTransaction = async (id, transaction)=>{\n        if (!supabase) return;\n        try {\n            // Adaptar los campos al esquema de expenses\n            const expenseToUpdate = {};\n            if (transaction.amount !== undefined) expenseToUpdate.amount = transaction.amount;\n            if (transaction.description !== undefined) expenseToUpdate.description = transaction.description;\n            if (transaction.date !== undefined) expenseToUpdate.date = transaction.date;\n            if (transaction.category_id !== undefined) expenseToUpdate.category_id = transaction.category_id;\n            if (transaction.type !== undefined) expenseToUpdate.type = transaction.type;\n            console.log('Actualizando transacción:', {\n                id,\n                ...expenseToUpdate\n            });\n            const { data, error } = await supabase.from('expenses').update(expenseToUpdate).eq('id', id).select().single();\n            if (error) throw error;\n            console.log('Transacción actualizada:', data);\n            // Recargar todas las transacciones para asegurar consistencia\n            const { data: transactionsData, error: transactionsError } = await supabase.from('expenses').select('*').order('created_at', {\n                ascending: false\n            });\n            if (transactionsError) throw transactionsError;\n            console.log('Transacciones actualizadas:', transactionsData);\n            setTransactions(transactionsData || []);\n            toast({\n                title: 'Transacción actualizada correctamente'\n            });\n        } catch (error) {\n            console.error('Error al actualizar transacción:', error);\n            toast({\n                title: 'Error al actualizar la transacción'\n            });\n            throw error;\n        }\n    };\n    // Eliminar una transacción\n    const deleteTransaction = async (id)=>{\n        if (!supabase) return;\n        try {\n            console.log('Eliminando transacción:', id);\n            const { error } = await supabase.from('expenses').delete().eq('id', id);\n            if (error) throw error;\n            // Recargar todas las transacciones para asegurar consistencia\n            const { data: transactionsData, error: transactionsError } = await supabase.from('expenses').select('*').order('created_at', {\n                ascending: false\n            });\n            if (transactionsError) throw transactionsError;\n            console.log('Transacciones actualizadas:', transactionsData);\n            setTransactions(transactionsData || []);\n            toast({\n                title: 'Transacción eliminada correctamente'\n            });\n        } catch (error) {\n            console.error('Error al eliminar transacción:', error);\n            toast({\n                title: 'Error al eliminar la transacción'\n            });\n            throw error;\n        }\n    };\n    // Obtener transacciones de un mes específico\n    const getMonthTransactions = (month)=>{\n        return transactions.filter((t)=>t.date.startsWith(month));\n    };\n    // Obtener resumen de un mes específico\n    const getMonthSummary = (month)=>{\n        const monthTransactions = getMonthTransactions(month);\n        const income = monthTransactions.filter((t)=>t.type === 'ingreso').reduce((sum, t)=>sum + t.amount, 0);\n        const expense = monthTransactions.filter((t)=>t.type === 'gasto').reduce((sum, t)=>sum + t.amount, 0);\n        return {\n            month,\n            income,\n            expense,\n            balance: income - expense\n        };\n    };\n    // Obtener resumen por categoría para un mes específico\n    const getMonthCategorySummary = (month, type)=>{\n        const monthTransactions = getMonthTransactions(month).filter((t)=>t.type === type);\n        const categorySummary = {};\n        monthTransactions.forEach((transaction)=>{\n            if (!categorySummary[transaction.category_id]) {\n                categorySummary[transaction.category_id] = 0;\n            }\n            categorySummary[transaction.category_id] += transaction.amount;\n        });\n        return Object.entries(categorySummary).map((param)=>{\n            let [category, amount] = param;\n            return {\n                category,\n                amount\n            };\n        }).sort((a, b)=>b.amount - a.amount);\n    };\n    // Obtener los últimos 6 meses para el gráfico de barras\n    const getLastSixMonthsSummary = ()=>{\n        const today = new Date();\n        const months = [];\n        for(let i = 0; i < 6; i++){\n            const d = new Date(today.getFullYear(), today.getMonth() - i, 1);\n            const month = \"\".concat(d.getFullYear(), \"-\").concat(String(d.getMonth() + 1).padStart(2, '0'));\n            months.push(month);\n        }\n        return months.map((month)=>getMonthSummary(month)).reverse();\n    };\n    // Obtener todos los meses del año actual para el gráfico de líneas\n    const getAllMonthsSummary = ()=>{\n        // Obtener todos los meses únicos de las transacciones\n        const months = Array.from(new Set(transactions.map((t)=>t.date.substring(0, 7)))).sort((a, b)=>b.localeCompare(a)) // Ordenar de más reciente a más antiguo\n        ;\n        return months.map((month)=>{\n            const monthTransactions = transactions.filter((t)=>t.date.startsWith(month));\n            const income = monthTransactions.filter((t)=>t.type === 'ingreso').reduce((sum, t)=>sum + Number(t.amount), 0);\n            const expense = monthTransactions.filter((t)=>t.type === 'gasto').reduce((sum, t)=>sum + Number(t.amount), 0);\n            return {\n                month,\n                income,\n                expense,\n                balance: income - expense\n            };\n        });\n    };\n    // Obtener el valor del dólar para un mes específico\n    const getDollarValue = (month)=>{\n        return dollarValues.find((d)=>d.month === month);\n    };\n    // Actualizar el valor del dólar para un mes específico\n    const updateDollarValue = async (month, value)=>{\n        if (!supabase) {\n            console.error('Supabase no está inicializado');\n            throw new Error('Supabase no está inicializado');\n        }\n        try {\n            // 1. Verificar autenticación\n            const { data: { user }, error: userError } = await supabase.auth.getUser();\n            if (userError) {\n                console.error('Error al obtener usuario:', userError);\n                throw new Error('Error al obtener usuario');\n            }\n            if (!user) {\n                console.error('No hay usuario autenticado');\n                throw new Error('No hay usuario autenticado');\n            }\n            console.log('Intentando actualizar valor del dólar:', {\n                user_id: user.id,\n                month,\n                value\n            });\n            // Intentar actualizar primero\n            const { data: updateData, error: updateError } = await supabase.from('dollar_values').update({\n                value\n            }).eq('user_id', user.id).eq('month', month).select().single();\n            if (updateError && updateError.code === 'PGRST116') {\n                console.log('Registro no encontrado, intentando insertar...');\n                const { data: insertData, error: insertError } = await supabase.from('dollar_values').insert({\n                    user_id: user.id,\n                    month,\n                    value\n                }).select().single();\n                if (insertError) {\n                    console.error('Error al insertar:', insertError);\n                    throw new Error(\"Error al insertar: \".concat(insertError.message));\n                }\n                setDollarValues((prev)=>{\n                    const newValues = [\n                        ...prev\n                    ];\n                    const index = newValues.findIndex((d)=>d.month === month);\n                    if (index >= 0) {\n                        newValues[index] = insertData;\n                    } else {\n                        newValues.push(insertData);\n                    }\n                    localStorage.setItem(\"dollar-values-\".concat(storageId), JSON.stringify(newValues));\n                    return newValues;\n                });\n                return insertData;\n            }\n            if (updateError) {\n                console.error('Error al actualizar:', updateError);\n                throw new Error(\"Error al actualizar: \".concat(updateError.message));\n            }\n            setDollarValues((prev)=>{\n                const newValues = [\n                    ...prev\n                ];\n                const index = newValues.findIndex((d)=>d.month === month);\n                if (index >= 0) {\n                    newValues[index] = updateData;\n                } else {\n                    newValues.push(updateData);\n                }\n                localStorage.setItem(\"dollar-values-\".concat(storageId), JSON.stringify(newValues));\n                return newValues;\n            });\n            return updateData;\n        } catch (error) {\n            console.error('Error al actualizar el valor del dólar:', error);\n            throw error;\n        }\n    };\n    return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(TransactionContext.Provider, {\n        value: {\n            transactions,\n            dollarValues,\n            addTransaction,\n            updateTransaction,\n            deleteTransaction,\n            getMonthTransactions,\n            getMonthSummary,\n            getLastSixMonthsSummary,\n            getAllMonthsSummary,\n            getDollarValue,\n            updateDollarValue,\n            getMonthCategorySummary,\n            isLoading\n        },\n        children: children\n    }, void 0, false, {\n        fileName: \"/Users/lnausan/Documents/Gastos V2/context/transaction-context.tsx\",\n        lineNumber: 506,\n        columnNumber: 5\n    }, this);\n}\n_s(TransactionProvider, \"BfKdZl4tHdqFexW0dynwWq34vGQ=\", false, function() {\n    return [\n        _components_providers_supabase_provider__WEBPACK_IMPORTED_MODULE_3__.useSupabase,\n        react__WEBPACK_IMPORTED_MODULE_1__.useOptimistic,\n        react__WEBPACK_IMPORTED_MODULE_1__.useOptimistic,\n        _components_ui_use_toast__WEBPACK_IMPORTED_MODULE_2__.useToast,\n        react__WEBPACK_IMPORTED_MODULE_1__.useId\n    ];\n});\n_c = TransactionProvider;\nfunction useTransactions() {\n    _s1();\n    const context = (0,react__WEBPACK_IMPORTED_MODULE_1__.useContext)(TransactionContext);\n    if (context === undefined) {\n        throw new Error(\"useTransactions must be used within a TransactionProvider\");\n    }\n    return context;\n}\n_s1(useTransactions, \"b9L3QQ+jgeyIrH0NfHrJ8nn7VMU=\");\nvar _c;\n$RefreshReg$(_c, \"TransactionProvider\");\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL2NvbnRleHQvdHJhbnNhY3Rpb24tY29udGV4dC50c3giLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7QUFJNkc7QUFFekQ7QUFDa0I7QUFFMUI7QUFrQjVDLE1BQU1VLG1DQUFxQlYsb0RBQWFBLENBQXFDVztBQUV0RSxTQUFTQyxvQkFBb0IsS0FBMkM7UUFBM0MsRUFBRUMsUUFBUSxFQUFpQyxHQUEzQzs7SUFDbEMsTUFBTSxFQUFFQyxRQUFRLEVBQUUsR0FBR1Asb0ZBQVdBO0lBQ2hDLE1BQU0sQ0FBQ1EsY0FBY0MsZ0JBQWdCLEdBQUdiLCtDQUFRQSxDQUFnQixFQUFFO0lBQ2xFLE1BQU0sQ0FBQ2MsY0FBY0MsZ0JBQWdCLEdBQUdmLCtDQUFRQSxDQUFnQixFQUFFO0lBQ2xFLE1BQU0sQ0FBQ2dCLFdBQVdDLGFBQWEsR0FBR2pCLCtDQUFRQSxDQUFDO0lBRTNDLE1BQU0sQ0FBQ2tCLHdCQUF3QkMseUJBQXlCLEdBQUdqQixvREFBYUEsQ0FHdEVVOzZDQUFjLENBQUNRO2dCQUFPLEVBQUVDLE1BQU0sRUFBRUMsSUFBSSxFQUFFO1lBQ3RDLElBQUlELFdBQVcsT0FBTztnQkFDcEIsT0FBTzt1QkFBSUQ7b0JBQU9FO2lCQUFLO1lBQ3pCLE9BQU8sSUFBSUQsV0FBVyxVQUFVO2dCQUM5QixPQUFPRCxNQUFNRyxHQUFHO3lEQUFDLENBQUNDLElBQU9BLEVBQUVDLEVBQUUsS0FBS0gsS0FBS0csRUFBRSxHQUFHOzRCQUFFLEdBQUdELENBQUM7NEJBQUUsR0FBR0YsS0FBS0ksV0FBVzt3QkFBQyxJQUFJRjs7WUFDOUUsT0FBTyxJQUFJSCxXQUFXLFVBQVU7Z0JBQzlCLE9BQU9ELE1BQU1PLE1BQU07eURBQUMsQ0FBQ0gsSUFBTUEsRUFBRUMsRUFBRSxLQUFLSCxLQUFLRyxFQUFFOztZQUM3QztZQUNBLE9BQU9MO1FBQ1Q7O0lBRUEsTUFBTSxDQUFDUSx3QkFBd0JDLHlCQUF5QixHQUFHM0Isb0RBQWFBLENBR3RFWTs2Q0FBYyxD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QUFDb0U7Z0JBQ2pCO2dCQUNBdEYsYUFBYThCLE9BQU8sQ0FBQyxpQkFBMkIsT0FBVmhDLFlBQWFLLEtBQUs0QixTQUFTLENBQUM2RDtnQkFDbEUsT0FBT0E7WUFDVDtZQUNBLE9BQU9OO1FBQ1QsRUFBRSxPQUFPL0UsT0FBTztZQUNkRCxRQUFRQyxLQUFLLENBQUMsMkNBQTJDQTtZQUN6RCxNQUFNQTtRQUNSO0lBQ0Y7SUFFQSxxQkFDRSw4REFBQ3JDLG1CQUFtQjRILFFBQVE7UUFDMUJULE9BQU87WUFDTDlHO1lBQ0FFO1lBQ0E2RDtZQUNBUztZQUNBRztZQUNBRTtZQUNBRTtZQUNBZ0I7WUFDQU07WUFDQU07WUFDQUU7WUFDQXZCO1lBQ0FsRjtRQUNGO2tCQUVDTjs7Ozs7O0FBR1A7R0FoZmdCRDs7UUFDT0wsZ0ZBQVdBO1FBSzJCRixnREFBYUE7UUFjYkEsZ0RBQWFBO1FBZXREQyw4REFBUUE7UUFDUkYsd0NBQUtBOzs7S0FwQ1RRO0FBa2ZULFNBQVMySDs7SUFDZCxNQUFNQyxVQUFVdkksaURBQVVBLENBQUNTO0lBQzNCLElBQUk4SCxZQUFZN0gsV0FBVztRQUN6QixNQUFNLElBQUlnRSxNQUFNO0lBQ2xCO0lBQ0EsT0FBTzZEO0FBQ1Q7SUFOZ0JEIiwic291cmNlcyI6WyIvVXNlcnMvbG5hdXNhbi9Eb2N1bWVudHMvR2FzdG9zIFYyL2NvbnRleHQvdHJhbnNhY3Rpb24tY29udGV4dC50c3giXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2UgY2xpZW50XCJcblxuaW1wb3J0IHR5cGUgUmVhY3QgZnJvbSBcInJlYWN0XCJcblxuaW1wb3J0IHsgY3JlYXRlQ29udGV4dCwgdXNlQ29udGV4dCwgdXNlRWZmZWN0LCB1c2VTdGF0ZSwgdXNlSWQsIHVzZU9wdGltaXN0aWMsIHN0YXJ0VHJhbnNpdGlvbiB9IGZyb20gXCJyZWFjdFwiXG5pbXBvcnQgdHlwZSB7IFRyYW5zYWN0aW9uLCBNb250aFN1bW1hcnksIERvbGxhclZhbHVlIH0gZnJvbSBcIkAvdHlwZXMvdHJhbnNhY3Rpb25cIlxuaW1wb3J0IHsgdXNlVG9hc3QgfSBmcm9tIFwiQC9jb21wb25lbnRzL3VpL3VzZS10b2FzdFwiXG5pbXBvcnQgeyB1c2VTdXBhYmFzZSB9IGZyb20gJ0AvY29tcG9uZW50cy9wcm92aWRlcnMvc3VwYWJhc2UtcHJvdmlkZXInXG5pbXBvcnQgeyB0b2FzdCB9IGZyb20gJ3Nvbm5lcidcbmltcG9ydCB7IGZvcm1hdCwgc3ViTW9udGhzIH0gZnJvbSBcImRhdGUtZm5zXCJcblxuaW50ZXJmYWNlIFRyYW5zYWN0aW9uQ29udGV4dFR5cGUge1xuICB0cmFuc2FjdGlvbnM6IFRyYW5zYWN0aW9uW11cbiAgZG9sbGFyVmFsdWVzOiBEb2xsYXJWYWx1ZVtdXG4gIGFkZFRyYW5zYWN0aW9uOiAodHJhbnNhY3Rpb246IE9taXQ8VHJhbnNhY3Rpb24sIFwiaWRcIiB8IFwiY3JlYXRlZF9hdFwiIHwgXCJ1cGRhdGVkX2F0XCIgfCBcInVzZXJfaWRcIj4pID0+IFByb21pc2U8dm9pZD5cbiAgdXBkYXRlVHJhbnNhY3Rpb246IChpZDogc3RyaW5nLCB0cmFuc2FjdGlvbjogUGFydGlhbDxUcmFuc2FjdGlvbj4pID0+IFByb21pc2U8dm9pZD5cbiAgZGVsZXRlVHJhbnNhY3Rpb246IChpZDogc3RyaW5nKSA9PiBQcm9taXNlPHZvaWQ+XG4gIGdldE1vbnRoVHJhbnNhY3Rpb25zOiAobW9udGg6IHN0cmluZykgPT4gVHJhbnNhY3Rpb25bXVxuICBnZXRNb250aFN1bW1hcnk6IChtb250aDogc3RyaW5nKSA9PiBNb250aFN1bW1hcnlcbiAgZ2V0TGFzdFNpeE1vbnRoc1N1bW1hcnk6ICgpID0+IE1vbnRoU3VtbWFyeVtdXG4gIGdldEFsbE1vbnRoc1N1bW1hcnk6ICgpID0+IE1vbnRoU3VtbWFyeVtdXG4gIGdldERvbGxhclZhbHVlOiAobW9udGg6IHN0cmluZykgPT4gRG9sbGFyVmFsdWUgfCB1bmRlZmluZWRcbiAgdXBkYXRlRG9sbGFyVmFsdWU6IChtb250aDogc3RyaW5nLCB2YWx1ZTogbnVtYmVyKSA9PiBQcm9taXNlPHZvaWQ+XG4gIGdldE1vbnRoQ2F0ZWdvcnlTdW1tYXJ5OiAobW9udGg6IHN0cmluZywgdHlwZTogXCJpbmdyZXNvXCIgfCBcImdhc3RvXCIpID0+IHsgY2F0ZWdvcnk6IHN0cmluZzsgYW1vdW50OiBudW1iZXIgfVtdXG4gIGlzTG9hZGluZzogYm9vbGVhblxufVxuXG5jb25zdCBUcmFuc2FjdGlvbkNvbnRleHQgPSBjcmVhdGVDb250ZXh0PFRyYW5zYWN0aW9uQ29udGV4dFR5cGUgfCB1bmRlZmluZWQ+KHVuZGVmaW5lZClcblxuZXhwb3J0IGZ1bmN0aW9uIFRyYW5zYWN0aW9uUHJvdmlkZXIoeyBjaGlsZHJlbiB9OiB7IGNoaWxkcmVuOiBSZWFjdC5SZWFjdE5vZGUgfSkge1xuICBjb25zdCB7IHN1cGFiYXNlIH0gPSB1c2VTdXBhYmFzZSgpXG4gIGNvbnN0IFt0cmFuc2FjdGlvbnMsIHNldFRyYW5zYWN0aW9uc10gPSB1c2VTdGF0ZTxUcmFuc2FjdGlvbltdPihbXSlcbiAgY29uc3QgW2RvbGxhclZhbHVlcywgc2V0RG9sbGFyVmFsdWVzXSA9IHVzZVN0YXRlPERvbGxhclZhbHVlW10+KFtdKVxuICBjb25zdCBbaXNMb2FkaW5nLCBzZXRJc0xvYWRpbmddID0gdXNlU3RhdGUodHJ1ZSlcblxuICBjb25zdCBbb3B0aW1pc3RpY1RyYW5zYWN0aW9ucywgYWRkT3B0aW1pc3RpY1RyYW5zYWN0aW9uXSA9IHVzZU9wdGltaXN0aWM8XG4gICAgVHJhbnNhY3Rpb25bXSxcbiAgICB7IGFjdGlvbjogXCJhZGRcIiB8IFwidXBkYXRlXCIgfCBcImRlbGV0ZVwiOyBkYXRhOiBhbnkgfVxuICA+KHRyYW5zYWN0aW9ucywgKHN0YXRlLCB7IGFjdGlvbiwgZGF0YSB9KSA9PiB7XG4gICAgaWYgKGFjdGlvbiA9PT0gXCJhZGRcIikge1xuICAgICAgcmV0dXJuIFsuLi5zdGF0ZSwgZGF0YV1cbiAgICB9IGVsc2UgaWYgKGFjdGlvbiA9PT0gXCJ1cGRhdGVcIikge1xuICAgICAgcmV0dXJuIHN0YXRlLm1hcCgodCkgPT4gKHQuaWQgPT09IGRhdGEuaWQgPyB7IC4uLnQsIC4uLmRhdGEudHJhbnNhY3Rpb24gfSA6IHQpKVxuICAgIH0gZWxzZSBpZiAoYWN0aW9uID09PSBcImRlbGV0ZVwiKSB7XG4gICAgICByZXR1cm4gc3RhdGUuZmlsdGVyKCh0KSA9PiB0LmlkICE9PSBkYXRhLmlkKVxuICAgIH1cbiAgICByZXR1cm4gc3RhdGVcbiAgfSlcblxuICBjb25zdCBbb3B0aW1pc3RpY0RvbGxhclZhbHVlcywgYWRkT3B0aW1pc3RpY0RvbGxhclZhbHVlXSA9IHVzZU9wdGltaXN0aWM8XG4gICAgRG9sbGFyVmFsdWVbXSxcbiAgICB7IGFjdGlvbjogXCJ1cGRhdGVcIjsgZGF0YTogYW55IH1cbiAgPihkb2xsYXJWYWx1ZXMsIChzdGF0ZSwgeyBhY3Rpb24sIGRhdGEgfSkgPT4ge1xuICAgIGlmIChhY3Rpb24gPT09IFwidXBkYXRlXCIpIHtcbiAgICAgIGNvbnN0IGV4aXN0aW5nSW5kZXggPSBzdGF0ZS5maW5kSW5kZXgoKGQpID0+IGQubW9udGggPT09IGRhdGEubW9udGgpXG4gICAgICBpZiAoZXhpc3RpbmdJbmRleCA+PSAwKSB7XG4gICAgICAgIHJldHVybiBzdGF0ZS5tYXAoKGQpID0+IChkLm1vbnRoID09PSBkYXRhLm1vbnRoID8gZGF0YSA6IGQpKVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIFsuLi5zdGF0ZSwgZGF0YV1cbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHN0YXRlXG4gIH0pXG5cbiAgY29uc3QgeyB0b2FzdCB9ID0gdXNlVG9hc3QoKVxuICBjb25zdCBzdG9yYWdlSWQgPSB1c2VJZCgpXG5cbiAgLy8gQ2FyZ2FyIHRyYW5zYWNjaW9uZXMgeSB2YWxvcmVzIGRlbCBkw7NsYXIgZGVzZGUgbG9jYWxTdG9yYWdlIGFsIGluaWNpYXJcbiAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICBpZiAoIXN1cGFiYXNlKSByZXR1cm5cblxuICAgIC8vIDEuIENhcmdhciBkYXRvcyBkZSBsb2NhbFN0b3JhZ2UgcHJpbWVyb1xuICAgIGNvbnN0IGNhY2hlZFRyYW5zYWN0aW9ucyA9IGxvY2FsU3RvcmFnZS5nZXRJdGVtKGB0cmFuc2FjdGlvbnMtJHtzdG9yYWdlSWR9YClcbiAgICBpZiAoY2FjaGVkVHJhbnNhY3Rpb25zKSB7XG4gICAgICB0cnkge1xuICAgICAgICBjb25zdCBwYXJzZWRUcmFuc2FjdGlvbnMgPSBKU09OLnBhcnNlKGNhY2hlZFRyYW5zYWN0aW9ucylcbiAgICAgICAgc2V0VHJhbnNhY3Rpb25zKHBhcnNlZFRyYW5zYWN0aW9ucylcbiAgICAgICAgc2V0SXNMb2FkaW5nKGZhbHNlKSAvLyBZYSB0ZW5lbW9zIGRhdG9zLCBubyBtb3N0cmFyIGxvYWRpbmdcbiAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgY29uc29sZS5lcnJvcignRXJyb3IgYWwgcGFyc2VhciB0cmFuc2FjY2lvbmVzIGRlbCBsb2NhbFN0b3JhZ2U6JywgZSlcbiAgICAgIH1cbiAgICB9XG5cbiAgICBjb25zdCBjYWNoZWREb2xsYXJWYWx1ZXMgPSBsb2NhbFN0b3JhZ2UuZ2V0SXRlbShgZG9sbGFyLXZhbHVlcy0ke3N0b3JhZ2VJZH1gKVxuICAgIGlmIChjYWNoZWREb2xsYXJWYWx1ZXMpIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIHNldERvbGxhclZhbHVlcyhKU09OLnBhcnNlKGNhY2hlZERvbGxhclZhbHVlcykpXG4gICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoJ0Vycm9yIGFsIHBhcnNlYXIgdmFsb3JlcyBkZWwgZMOzbGFyIGRlbCBsb2NhbFN0b3JhZ2U6JywgZSlcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyAyLiBMdWVnbyBjYXJnYXIgZGVzZGUgU3VwYWJhc2UgZW4gc2VndW5kbyBwbGFub1xuICAgIGNvbnN0IGxvYWREYXRhID0gYXN5bmMgKCkgPT4ge1xuICAgICAgdHJ5IHtcbiAgICAgICAgY29uc3QgeyBkYXRhOiB7IHVzZXIgfSwgZXJyb3I6IHVzZXJFcnJvciB9ID0gYXdhaXQgc3VwYWJhc2UuYXV0aC5nZXRVc2VyKClcbiAgICAgICAgaWYgKHVzZXJFcnJvcikge1xuICAgICAgICAgIGNvbnNvbGUuZXJyb3IoJ0Vycm9yIGFsIG9idGVuZXIgdXN1YXJpbzonLCB1c2VyRXJyb3IpXG4gICAgICAgICAgdGhyb3cgdXNlckVycm9yXG4gICAgICAgIH1cbiAgICAgICAgaWYgKCF1c2VyKSB7XG4gICAgICAgICAgY29uc29sZS5lcnJvcignTm8gaGF5IHVzdWFyaW8gYXV0ZW50aWNhZG8nKVxuICAgICAgICAgIHJldHVyblxuICAgICAgICB9XG5cbiAgICAgICAgLy8gQ2FsY3VsYXIgbG9zIMO6bHRpbW9zIDYgbWVzZXNcbiAgICAgICAgY29uc3QgdG9kYXkgPSBuZXcgRGF0ZSgpXG4gICAgICAgIGNvbnN0IG1vbnRoczogc3RyaW5nW10gPSBbXVxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IDY7IGkrKykge1xuICAgICAgICAgIGNvbnN0IGQgPSBzdWJNb250aHModG9kYXksIGkpXG4gICAgICAgICAgbW9udGhzLnB1c2goZm9ybWF0KGQsIFwieXl5eS1NTVwiKSlcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnNvbGUubG9nKCdCdXNjYW5kbyB0cmFuc2FjY2lvbmVzIHBhcmEgbG9zIG1lc2VzOicsIG1vbnRocylcblxuICAgICAgICAvLyBUcmFlciBzb2xvIGxhcyB0cmFuc2FjY2lvbmVzIGRlIGxvcyDDumx0aW1vcyA2IG1lc2VzXG4gICAgICAgIGNvbnN0IHsgZGF0YTogdHJhbnNhY3Rpb25zRGF0YSwgZXJyb3I6IHRyYW5zYWN0aW9uc0Vycm9yIH0gPSBhd2FpdCBzdXBhYmFzZVxuICAgICAgICAgIC5mcm9tKCdleHBlbnNlcycpXG4gICAgICAgICAgLnNlbGVjdCgnKicpXG4gICAgICAgICAgLmVxKCd1c2VyX2lkJywgdXNlci5pZClcbiAgICAgICAgICAuZ3RlKCdkYXRlJywgYCR7bW9udGhzW21vbnRocy5sZW5ndGggLSAxXX0tMDFgKVxuICAgICAgICAgIC5sdGUoJ2RhdGUnLCBgJHttb250aHNbMF19LTMxYClcbiAgICAgICAgICAub3JkZXIoJ2NyZWF0ZWRfYXQnLCB7IGFzY2VuZGluZzogZmFsc2UgfSlcblxuICAgICAgICBpZiAodHJhbnNhY3Rpb25zRXJyb3IpIHtcbiAgICAgICAgICBjb25zb2xlLmVycm9yKCdFcnJvciBhbCBjYXJnYXIgdHJhbnNhY2Npb25lczonLCB0cmFuc2FjdGlvbnNFcnJvcilcbiAgICAgICAgICB0aHJvdyB0cmFuc2FjdGlvbnNFcnJvclxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHRyYW5zYWN0aW9uc0RhdGEpIHtcbiAgICAgICAgICBjb25zb2xlLmxvZygnVHJhbnNhY2Npb25lcyBjYXJnYWRhczonLCB0cmFuc2FjdGlvbnNEYXRhLmxlbmd0aClcbiAgICAgICAgICBzZXRUcmFuc2FjdGlvbnModHJhbnNhY3Rpb25zRGF0YSlcbiAgICAgICAgICBsb2NhbFN0b3JhZ2Uuc2V0SXRlbShgdHJhbnNhY3Rpb25zLSR7c3RvcmFnZUlkfWAsIEpTT04uc3RyaW5naWZ5KHRyYW5zYWN0aW9uc0RhdGEpKVxuICAgICAgICB9XG5cbiAgICAgICAgY29uc29sZS5sb2coJ0J1c2NhbmRvIHZhbG9yZXMgZGVsIGTDs2xhciBwYXJhIGxvcyBtZXNlczonLCBtb250aHMpXG5cbiAgICAgICAgLy8gVHJhZXIgdG9kb3MgbG9zIHZhbG9yZXMgZGVsIGTDs2xhciBkZWwgdXN1YXJpb1xuICAgICAgICBjb25zdCBsb2FkRG9sbGFyVmFsdWVzID0gYXN5bmMgKCkgPT4ge1xuICAgICAgICAgIGlmICghc3VwYWJhc2UpIHtcbiAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoJ1N1cGFiYXNlIG5vIGVzdMOhIGluaWNpYWxpemFkbycpXG4gICAgICAgICAgICByZXR1cm5cbiAgICAgICAgICB9XG5cbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgLy8gMS4gVmVyaWZpY2FyIGF1dGVudGljYWNpw7NuXG4gICAgICAgICAgICBjb25zdCB7IGRhdGE6IHsgdXNlciB9LCBlcnJvcjogdXNlckVycm9yIH0gPSBhd2FpdCBzdXBhYmFzZS5hdXRoLmdldFVzZXIoKVxuICAgICAgICAgICAgaWYgKHVzZXJFcnJvcikge1xuICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKCdFcnJvciBhbCBvYnRlbmVyIHVzdWFyaW86JywgdXNlckVycm9yKVxuICAgICAgICAgICAgICByZXR1cm5cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghdXNlcikge1xuICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKCdObyBoYXkgdXN1YXJpbyBhdXRlbnRpY2FkbycpXG4gICAgICAgICAgICAgIHJldHVyblxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBjb25zb2xlLmxvZygnQ2FyZ2FuZG8gaGlzdG9yaWFsIGRlIHZhbG9yZXMgZGVsIGTDs2xhciBwYXJhIHVzdWFyaW86JywgdXNlci5pZClcblxuICAgICAgICAgICAgLy8gMi4gQ2FyZ2FyIHRvZG9zIGxvcyB2YWxvcmVzIGhpc3TDs3JpY29zXG4gICAgICAgICAgICBjb25zdCB7IGRhdGEsIGVycm9yIH0gPSBhd2FpdCBzdXBhYmFzZVxuICAgICAgICAgICAgICAuZnJvbSgnZG9sbGFyX3ZhbHVlcycpXG4gICAgICAgICAgICAgIC5zZWxlY3QoJyonKVxuICAgICAgICAgICAgICAuZXEoJ3VzZXJfaWQnLCB1c2VyLmlkKVxuICAgICAgICAgICAgICAub3JkZXIoJ21vbnRoJywgeyBhc2NlbmRpbmc6IGZhbHNlIH0pXG5cbiAgICAgICAgICAgIGNvbnNvbGUubG9nKCdSZXNwdWVzdGEgZGUgbGEgY2FyZ2EgZGUgZMOzbGFyZXM6JywgeyBkYXRhLCBlcnJvciB9KVxuXG4gICAgICAgICAgICBpZiAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgY29uc29sZS5lcnJvcignRXJyb3IgYWwgY2FyZ2FyIHZhbG9yZXMgZGVsIGTDs2xhcjonLCBlcnJvcilcbiAgICAgICAgICAgICAgcmV0dXJuXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmICghZGF0YSkge1xuICAgICAgICAgICAgICBjb25zb2xlLmxvZygnTm8gc2UgZW5jb250cmFyb24gdmFsb3JlcyBkZWwgZMOzbGFyJylcbiAgICAgICAgICAgICAgc2V0RG9sbGFyVmFsdWVzKFtdKVxuICAgICAgICAgICAgICBsb2NhbFN0b3JhZ2Uuc2V0SXRlbShgZG9sbGFyLXZhbHVlcy0ke3N0b3JhZ2VJZH1gLCBKU09OLnN0cmluZ2lmeShbXSkpXG4gICAgICAgICAgICAgIHJldHVyblxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBjb25zb2xlLmxvZygnSGlzdG9yaWFsIGRlIHZhbG9yZXMgZGVsIGTDs2xhciBjYXJnYWRvczonLCBkYXRhKVxuICAgICAgICAgICAgc2V0RG9sbGFyVmFsdWVzKGRhdGEpXG4gICAgICAgICAgICBsb2NhbFN0b3JhZ2Uuc2V0SXRlbShgZG9sbGFyLXZhbHVlcy0ke3N0b3JhZ2VJZH1gLCBKU09OLnN0cmluZ2lmeShkYXRhKSlcblxuICAgICAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICBjb25zb2xlLmVycm9yKCdFcnJvciBpbmVzcGVyYWRvIGFsIGNhcmdhciB2YWxvcmVzIGRlbCBkw7NsYXI6JywgZXJyb3IpXG4gICAgICAgICAgICBzZXREb2xsYXJWYWx1ZXMoW10pXG4gICAgICAgICAgICBsb2NhbFN0b3JhZ2Uuc2V0SXRlbShgZG9sbGFyLXZhbHVlcy0ke3N0b3JhZ2VJZH1gLCBKU09OLnN0cmluZ2lmeShbXSkpXG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gRWplY3V0YXIgbGEgY2FyZ2EgZGUgZGF0b3NcbiAgICAgICAgYXdhaXQgbG9hZERvbGxhclZhbHVlcygpXG4gICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICBjb25zb2xlLmVycm9yKCdFcnJvciBkZXRhbGxhZG8gYWwgY2FyZ2FyIGRhdG9zOicsIGVycm9yKVxuICAgICAgICAvLyBObyBtb3N0cmFyIGVsIGVycm9yIGFsIHVzdWFyaW8gc2kgeWEgdGVuZW1vcyBkYXRvcyBlbiBsb2NhbFN0b3JhZ2VcbiAgICAgICAgaWYgKHRyYW5zYWN0aW9ucy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICB0b2FzdCh7XG4gICAgICAgICAgICB0aXRsZTogJ0Vycm9yIGFsIGNhcmdhciBsb3MgZGF0b3MnLFxuICAgICAgICAgICAgZGVzY3JpcHRpb246IGVycm9yIGluc3RhbmNlb2YgRXJyb3IgPyBlcnJvci5tZXNzYWdlIDogJ0Vycm9yIGRlc2Nvbm9jaWRvJyxcbiAgICAgICAgICAgIHZhcmlhbnQ6ICdkZXN0cnVjdGl2ZSdcbiAgICAgICAgICB9KVxuICAgICAgICB9XG4gICAgICB9IGZpbmFsbHkge1xuICAgICAgICBzZXRJc0xvYWRpbmcoZmFsc2UpXG4gICAgICB9XG4gICAgfVxuXG4gICAgbG9hZERhdGEoKVxuICB9LCBbc3VwYWJhc2VdKVxuXG4gIC8vIEFncmVnYXIgdW5hIG51ZXZhIHRyYW5zYWNjacOzblxuICBjb25zdCBhZGRUcmFuc2FjdGlvbiA9IGFzeW5jICh0cmFuc2FjdGlvbjogT21pdDxUcmFuc2FjdGlvbiwgXCJpZFwiIHwgXCJjcmVhdGVkX2F0XCIgfCBcInVwZGF0ZWRfYXRcIiB8IFwidXNlcl9pZFwiPikgPT4ge1xuICAgIGlmICghc3VwYWJhc2UpIHJldHVyblxuXG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IHsgZGF0YTogeyB1c2VyIH0gfSA9IGF3YWl0IHN1cGFiYXNlLmF1dGguZ2V0VXNlcigpXG4gICAgICBpZiAoIXVzZXIpIHtcbiAgICAgICAgY29uc29sZS5lcnJvcignTm8gc2UgcHVkbyBvYnRlbmVyIGVsIHVzdWFyaW8gYXV0ZW50aWNhZG8nKVxuICAgICAgICByZXR1cm5cbiAgICAgIH1cblxuICAgICAgY29uc3QgZXhwZW5zZVRvSW5zZXJ0ID0ge1xuICAgICAgICBhbW91bnQ6IHRyYW5zYWN0aW9uLmFtb3VudCxcbiAgICAgICAgZGVzY3JpcHRpb246IHRyYW5zYWN0aW9uLmRlc2NyaXB0aW9uLFxuICAgICAgICBkYXRlOiB0cmFuc2FjdGlvbi5kYXRlLFxuICAgICAgICBjYXRlZ29yeV9pZDogdHJhbnNhY3Rpb24uY2F0ZWdvcnlfaWQsXG4gICAgICAgIHVzZXJfaWQ6IHVzZXIuaWQsXG4gICAgICAgIHR5cGU6IHRyYW5zYWN0aW9uLnR5cGUsXG4gICAgfVxuXG4gICAgICBjb25zb2xlLmxvZygnSW5zZXJ0YW5kbyBlbiBTdXBhYmFzZTonLCBleHBlbnNlVG9JbnNlcnQpXG5cbiAgICAgIGNvbnN0IHsgZGF0YSwgZXJyb3IgfSA9IGF3YWl0IHN1cGFiYXNlXG4gICAgICAgIC5mcm9tKCdleHBlbnNlcycpXG4gICAgICAgIC5pbnNlcnQoW2V4cGVuc2VUb0luc2VydF0pXG4gICAgICAgIC5zZWxlY3QoKVxuICAgICAgICAuc2luZ2xlKClcblxuICAgICAgY29uc29sZS5sb2coJ1Jlc3B1ZXN0YSBkZSBTdXBhYmFzZTonLCB7IGRhdGEsIGVycm9yIH0pXG5cbiAgICAgIGlmIChlcnJvcikgdGhyb3cgZXJyb3JcblxuICAgICAgLy8gUmVjYXJnYXIgdG9kYXMgbGFzIHRyYW5zYWNjaW9uZXMgcGFyYSBhc2VndXJhciBjb25zaXN0ZW5jaWFcbiAgICAgIGNvbnN0IHsgZGF0YTogdHJhbnNhY3Rpb25zRGF0YSwgZXJyb3I6IHRyYW5zYWN0aW9uc0Vycm9yIH0gPSBhd2FpdCBzdXBhYmFzZVxuICAgICAgICAuZnJvbSgnZXhwZW5zZXMnKVxuICAgICAgICAuc2VsZWN0KCcqJylcbiAgICAgICAgLmVxKCd1c2VyX2lkJywgdXNlci5pZClcbiAgICAgICAgLm9yZGVyKCdjcmVhdGVkX2F0JywgeyBhc2NlbmRpbmc6IGZhbHNlIH0pXG5cbiAgICAgIGlmICh0cmFuc2FjdGlvbnNFcnJvcikgdGhyb3cgdHJhbnNhY3Rpb25zRXJyb3JcblxuICAgICAgY29uc29sZS5sb2coJ1RyYW5zYWNjaW9uZXMgYWN0dWFsaXphZGFzOicsIHRyYW5zYWN0aW9uc0RhdGEpXG4gICAgICBzZXRUcmFuc2FjdGlvbnModHJhbnNhY3Rpb25zRGF0YSB8fCBbXSlcbiAgICAgIHRvYXN0KHsgdGl0bGU6ICdUcmFuc2FjY2nDs24gYWdyZWdhZGEgY29ycmVjdGFtZW50ZScgfSlcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgY29uc29sZS5lcnJvcignRXJyb3IgYWwgYWdyZWdhciB0cmFuc2FjY2nDs246JywgZXJyb3IpXG4gICAgICB0b2FzdCh7IHRpdGxlOiAnRXJyb3IgYWwgYWdyZWdhciBsYSB0cmFuc2FjY2nDs24nIH0pXG4gICAgICB0aHJvdyBlcnJvclxuICAgIH1cbiAgfVxuXG4gIC8vIEFjdHVhbGl6YXIgdW5hIHRyYW5zYWNjacOzbiBleGlzdGVudGVcbiAgY29uc3QgdXBkYXRlVHJhbnNhY3Rpb24gPSBhc3luYyAoaWQ6IHN0cmluZywgdHJhbnNhY3Rpb246IFBhcnRpYWw8VHJhbnNhY3Rpb24+KSA9PiB7XG4gICAgaWYgKCFzdXBhYmFzZSkgcmV0dXJuXG5cbiAgICB0cnkge1xuICAgICAgLy8gQWRhcHRhciBsb3MgY2FtcG9zIGFsIGVzcXVlbWEgZGUgZXhwZW5zZXNcbiAgICAgIGNvbnN0IGV4cGVuc2VUb1VwZGF0ZTogYW55ID0ge31cbiAgICAgIGlmICh0cmFuc2FjdGlvbi5hbW91bnQgIT09IHVuZGVmaW5lZCkgZXhwZW5zZVRvVXBkYXRlLmFtb3VudCA9IHRyYW5zYWN0aW9uLmFtb3VudFxuICAgICAgaWYgKHRyYW5zYWN0aW9uLmRlc2NyaXB0aW9uICE9PSB1bmRlZmluZWQpIGV4cGVuc2VUb1VwZGF0ZS5kZXNjcmlwdGlvbiA9IHRyYW5zYWN0aW9uLmRlc2NyaXB0aW9uXG4gICAgICBpZiAodHJhbnNhY3Rpb24uZGF0ZSAhPT0gdW5kZWZpbmVkKSBleHBlbnNlVG9VcGRhdGUuZGF0ZSA9IHRyYW5zYWN0aW9uLmRhdGVcbiAgICAgIGlmICh0cmFuc2FjdGlvbi5jYXRlZ29yeV9pZCAhPT0gdW5kZWZpbmVkKSBleHBlbnNlVG9VcGRhdGUuY2F0ZWdvcnlfaWQgPSB0cmFuc2FjdGlvbi5jYXRlZ29yeV9pZFxuICAgICAgaWYgKHRyYW5zYWN0aW9uLnR5cGUgIT09IHVuZGVmaW5lZCkgZXhwZW5zZVRvVXBkYXRlLnR5cGUgPSB0cmFuc2FjdGlvbi50eXBlXG5cbiAgICAgIGNvbnNvbGUubG9nKCdBY3R1YWxpemFuZG8gdHJhbnNhY2Npw7NuOicsIHsgaWQsIC4uLmV4cGVuc2VUb1VwZGF0ZSB9KVxuXG4gICAgICBjb25zdCB7IGRhdGEsIGVycm9yIH0gPSBhd2FpdCBzdXBhYmFzZVxuICAgICAgICAuZnJvbSgnZXhwZW5zZXMnKVxuICAgICAgICAudXBkYXRlKGV4cGVuc2VUb1VwZGF0ZSlcbiAgICAgICAgLmVxKCdpZCcsIGlkKVxuICAgICAgICAuc2VsZWN0KClcbiAgICAgICAgLnNpbmdsZSgpXG5cbiAgICAgIGlmIChlcnJvcikgdGhyb3cgZXJyb3JcblxuICAgICAgY29uc29sZS5sb2coJ1RyYW5zYWNjacOzbiBhY3R1YWxpemFkYTonLCBkYXRhKVxuXG4gICAgICAvLyBSZWNhcmdhciB0b2RhcyBsYXMgdHJhbnNhY2Npb25lcyBwYXJhIGFzZWd1cmFyIGNvbnNpc3RlbmNpYVxuICAgICAgY29uc3QgeyBkYXRhOiB0cmFuc2FjdGlvbnNEYXRhLCBlcnJvcjogdHJhbnNhY3Rpb25zRXJyb3IgfSA9IGF3YWl0IHN1cGFiYXNlXG4gICAgICAgIC5mcm9tKCdleHBlbnNlcycpXG4gICAgICAgIC5zZWxlY3QoJyonKVxuICAgICAgICAub3JkZXIoJ2NyZWF0ZWRfYXQnLCB7IGFzY2VuZGluZzogZmFsc2UgfSlcblxuICAgICAgaWYgKHRyYW5zYWN0aW9uc0Vycm9yKSB0aHJvdyB0cmFuc2FjdGlvbnNFcnJvclxuXG4gICAgICBjb25zb2xlLmxvZygnVHJhbnNhY2Npb25lcyBhY3R1YWxpemFkYXM6JywgdHJhbnNhY3Rpb25zRGF0YSlcbiAgICAgIHNldFRyYW5zYWN0aW9ucyh0cmFuc2FjdGlvbnNEYXRhIHx8IFtdKVxuICAgICAgdG9hc3QoeyB0aXRsZTogJ1RyYW5zYWNjacOzbiBhY3R1YWxpemFkYSBjb3JyZWN0YW1lbnRlJyB9KVxuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBjb25zb2xlLmVycm9yKCdFcnJvciBhbCBhY3R1YWxpemFyIHRyYW5zYWNjacOzbjonLCBlcnJvcilcbiAgICAgIHRvYXN0KHsgdGl0bGU6ICdFcnJvciBhbCBhY3R1YWxpemFyIGxhIHRyYW5zYWNjacOzbicgfSlcbiAgICAgIHRocm93IGVycm9yXG4gICAgfVxuICB9XG5cbiAgLy8gRWxpbWluYXIgdW5hIHRyYW5zYWNjacOzblxuICBjb25zdCBkZWxldGVUcmFuc2FjdGlvbiA9IGFzeW5jIChpZDogc3RyaW5nKSA9PiB7XG4gICAgaWYgKCFzdXBhYmFzZSkgcmV0dXJuXG5cbiAgICB0cnkge1xuICAgICAgY29uc29sZS5sb2coJ0VsaW1pbmFuZG8gdHJhbnNhY2Npw7NuOicsIGlkKVxuXG4gICAgICBjb25zdCB7IGVycm9yIH0gPSBhd2FpdCBzdXBhYmFzZS5mcm9tKCdleHBlbnNlcycpLmRlbGV0ZSgpLmVxKCdpZCcsIGlkKVxuXG4gICAgICBpZiAoZXJyb3IpIHRocm93IGVycm9yXG5cbiAgICAgIC8vIFJlY2FyZ2FyIHRvZGFzIGxhcyB0cmFuc2FjY2lvbmVzIHBhcmEgYXNlZ3VyYXIgY29uc2lzdGVuY2lhXG4gICAgICBjb25zdCB7IGRhdGE6IHRyYW5zYWN0aW9uc0RhdGEsIGVycm9yOiB0cmFuc2FjdGlvbnNFcnJvciB9ID0gYXdhaXQgc3VwYWJhc2VcbiAgICAgICAgLmZyb20oJ2V4cGVuc2VzJylcbiAgICAgICAgLnNlbGVjdCgnKicpXG4gICAgICAgIC5vcmRlcignY3JlYXRlZF9hdCcsIHsgYXNjZW5kaW5nOiBmYWxzZSB9KVxuXG4gICAgICBpZiAodHJhbnNhY3Rpb25zRXJyb3IpIHRocm93IHRyYW5zYWN0aW9uc0Vycm9yXG5cbiAgICAgIGNvbnNvbGUubG9nKCdUcmFuc2FjY2lvbmVzIGFjdHVhbGl6YWRhczonLCB0cmFuc2FjdGlvbnNEYXRhKVxuICAgICAgc2V0VHJhbnNhY3Rpb25zKHRyYW5zYWN0aW9uc0RhdGEgfHwgW10pXG4gICAgICB0b2FzdCh7IHRpdGxlOiAnVHJhbnNhY2Npw7NuIGVsaW1pbmFkYSBjb3JyZWN0YW1lbnRlJyB9KVxuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBjb25zb2xlLmVycm9yKCdFcnJvciBhbCBlbGltaW5hciB0cmFuc2FjY2nDs246JywgZXJyb3IpXG4gICAgICB0b2FzdCh7IHRpdGxlOiAnRXJyb3IgYWwgZWxpbWluYXIgbGEgdHJhbnNhY2Npw7NuJyB9KVxuICAgICAgdGhyb3cgZXJyb3JcbiAgICB9XG4gIH1cblxuICAvLyBPYnRlbmVyIHRyYW5zYWNjaW9uZXMgZGUgdW4gbWVzIGVzcGVjw61maWNvXG4gIGNvbnN0IGdldE1vbnRoVHJhbnNhY3Rpb25zID0gKG1vbnRoOiBzdHJpbmcpID0+IHtcbiAgICByZXR1cm4gdHJhbnNhY3Rpb25zLmZpbHRlcigodCkgPT4gdC5kYXRlLnN0YXJ0c1dpdGgobW9udGgpKVxuICB9XG5cbiAgLy8gT2J0ZW5lciByZXN1bWVuIGRlIHVuIG1lcyBlc3BlY8OtZmljb1xuICBjb25zdCBnZXRNb250aFN1bW1hcnkgPSAobW9udGg6IHN0cmluZyk6IE1vbnRoU3VtbWFyeSA9PiB7XG4gICAgY29uc3QgbW9udGhUcmFuc2FjdGlvbnMgPSBnZXRNb250aFRyYW5zYWN0aW9ucyhtb250aClcbiAgICBjb25zdCBpbmNvbWUgPSBtb250aFRyYW5zYWN0aW9uc1xuICAgICAgLmZpbHRlcigodCkgPT4gdC50eXBlID09PSAnaW5ncmVzbycpXG4gICAgICAucmVkdWNlKChzdW0sIHQpID0+IHN1bSArIHQuYW1vdW50LCAwKVxuICAgIGNvbnN0IGV4cGVuc2UgPSBtb250aFRyYW5zYWN0aW9uc1xuICAgICAgLmZpbHRlcigodCkgPT4gdC50eXBlID09PSAnZ2FzdG8nKVxuICAgICAgLnJlZHVjZSgoc3VtLCB0KSA9PiBzdW0gKyB0LmFtb3VudCwgMClcblxuICAgIHJldHVybiB7XG4gICAgICBtb250aCxcbiAgICAgIGluY29tZSxcbiAgICAgIGV4cGVuc2UsXG4gICAgICBiYWxhbmNlOiBpbmNvbWUgLSBleHBlbnNlLFxuICAgIH1cbiAgfVxuXG4gIC8vIE9idGVuZXIgcmVzdW1lbiBwb3IgY2F0ZWdvcsOtYSBwYXJhIHVuIG1lcyBlc3BlY8OtZmljb1xuICBjb25zdCBnZXRNb250aENhdGVnb3J5U3VtbWFyeSA9IChtb250aDogc3RyaW5nLCB0eXBlOiAnaW5ncmVzbycgfCAnZ2FzdG8nKSA9PiB7XG4gICAgY29uc3QgbW9udGhUcmFuc2FjdGlvbnMgPSBnZXRNb250aFRyYW5zYWN0aW9ucyhtb250aCkuZmlsdGVyKCh0KSA9PiB0LnR5cGUgPT09IHR5cGUpXG4gICAgY29uc3QgY2F0ZWdvcnlTdW1tYXJ5OiBSZWNvcmQ8c3RyaW5nLCBudW1iZXI+ID0ge31cblxuICAgIG1vbnRoVHJhbnNhY3Rpb25zLmZvckVhY2goKHRyYW5zYWN0aW9uKSA9PiB7XG4gICAgICBpZiAoIWNhdGVnb3J5U3VtbWFyeVt0cmFuc2FjdGlvbi5jYXRlZ29yeV9pZF0pIHtcbiAgICAgICAgY2F0ZWdvcnlTdW1tYXJ5W3RyYW5zYWN0aW9uLmNhdGVnb3J5X2lkXSA9IDBcbiAgICAgIH1cbiAgICAgIGNhdGVnb3J5U3VtbWFyeVt0cmFuc2FjdGlvbi5jYXRlZ29yeV9pZF0gKz0gdHJhbnNhY3Rpb24uYW1vdW50XG4gICAgfSlcblxuICAgIHJldHVybiBPYmplY3QuZW50cmllcyhjYXRlZ29yeVN1bW1hcnkpXG4gICAgICAubWFwKChbY2F0ZWdvcnksIGFtb3VudF0pID0+ICh7XG4gICAgICAgIGNhdGVnb3J5LFxuICAgICAgICBhbW91bnQsXG4gICAgICB9KSlcbiAgICAgIC5zb3J0KChhLCBiKSA9PiBiLmFtb3VudCAtIGEuYW1vdW50KVxuICB9XG5cbiAgLy8gT2J0ZW5lciBsb3Mgw7psdGltb3MgNiBtZXNlcyBwYXJhIGVsIGdyw6FmaWNvIGRlIGJhcnJhc1xuICBjb25zdCBnZXRMYXN0U2l4TW9udGhzU3VtbWFyeSA9ICgpOiBNb250aFN1bW1hcnlbXSA9PiB7XG4gICAgY29uc3QgdG9kYXkgPSBuZXcgRGF0ZSgpXG4gICAgY29uc3QgbW9udGhzOiBzdHJpbmdbXSA9IFtdXG5cbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IDY7IGkrKykge1xuICAgICAgY29uc3QgZCA9IG5ldyBEYXRlKHRvZGF5LmdldEZ1bGxZZWFyKCksIHRvZGF5LmdldE1vbnRoKCkgLSBpLCAxKVxuICAgICAgY29uc3QgbW9udGggPSBgJHtkLmdldEZ1bGxZZWFyKCl9LSR7U3RyaW5nKGQuZ2V0TW9udGgoKSArIDEpLnBhZFN0YXJ0KDIsICcwJyl9YFxuICAgICAgbW9udGhzLnB1c2gobW9udGgpXG4gICAgfVxuXG4gICAgcmV0dXJuIG1vbnRocy5tYXAoKG1vbnRoKSA9PiBnZXRNb250aFN1bW1hcnkobW9udGgpKS5yZXZlcnNlKClcbiAgfVxuXG4gIC8vIE9idGVuZXIgdG9kb3MgbG9zIG1lc2VzIGRlbCBhw7FvIGFjdHVhbCBwYXJhIGVsIGdyw6FmaWNvIGRlIGzDrW5lYXNcbiAgY29uc3QgZ2V0QWxsTW9udGhzU3VtbWFyeSA9ICgpOiBNb250aFN1bW1hcnlbXSA9PiB7XG4gICAgLy8gT2J0ZW5lciB0b2RvcyBsb3MgbWVzZXMgw7puaWNvcyBkZSBsYXMgdHJhbnNhY2Npb25lc1xuICAgIGNvbnN0IG1vbnRocyA9IEFycmF5LmZyb20obmV3IFNldCh0cmFuc2FjdGlvbnMubWFwKHQgPT4gdC5kYXRlLnN1YnN0cmluZygwLCA3KSkpKVxuICAgICAgLnNvcnQoKGEsIGIpID0+IGIubG9jYWxlQ29tcGFyZShhKSkgLy8gT3JkZW5hciBkZSBtw6FzIHJlY2llbnRlIGEgbcOhcyBhbnRpZ3VvXG5cbiAgICByZXR1cm4gbW9udGhzLm1hcChtb250aCA9PiB7XG4gICAgICBjb25zdCBtb250aFRyYW5zYWN0aW9ucyA9IHRyYW5zYWN0aW9ucy5maWx0ZXIodCA9PiB0LmRhdGUuc3RhcnRzV2l0aChtb250aCkpXG4gICAgICBjb25zdCBpbmNvbWUgPSBtb250aFRyYW5zYWN0aW9uc1xuICAgICAgICAuZmlsdGVyKHQgPT4gdC50eXBlID09PSAnaW5ncmVzbycpXG4gICAgICAgIC5yZWR1Y2UoKHN1bSwgdCkgPT4gc3VtICsgTnVtYmVyKHQuYW1vdW50KSwgMClcbiAgICAgIGNvbnN0IGV4cGVuc2UgPSBtb250aFRyYW5zYWN0aW9uc1xuICAgICAgICAuZmlsdGVyKHQgPT4gdC50eXBlID09PSAnZ2FzdG8nKVxuICAgICAgICAucmVkdWNlKChzdW0sIHQpID0+IHN1bSArIE51bWJlcih0LmFtb3VudCksIDApXG5cbiAgICAgIHJldHVybiB7XG4gICAgICAgIG1vbnRoLFxuICAgICAgICBpbmNvbWUsXG4gICAgICAgIGV4cGVuc2UsXG4gICAgICAgIGJhbGFuY2U6IGluY29tZSAtIGV4cGVuc2VcbiAgICAgIH1cbiAgICB9KVxuICB9XG5cbiAgLy8gT2J0ZW5lciBlbCB2YWxvciBkZWwgZMOzbGFyIHBhcmEgdW4gbWVzIGVzcGVjw61maWNvXG4gIGNvbnN0IGdldERvbGxhclZhbHVlID0gKG1vbnRoOiBzdHJpbmcpOiBEb2xsYXJWYWx1ZSB8IHVuZGVmaW5lZCA9PiB7XG4gICAgcmV0dXJuIGRvbGxhclZhbHVlcy5maW5kKChkKSA9PiBkLm1vbnRoID09PSBtb250aClcbiAgfVxuXG4gIC8vIEFjdHVhbGl6YXIgZWwgdmFsb3IgZGVsIGTDs2xhciBwYXJhIHVuIG1lcyBlc3BlY8OtZmljb1xuICBjb25zdCB1cGRhdGVEb2xsYXJWYWx1ZSA9IGFzeW5jIChtb250aDogc3RyaW5nLCB2YWx1ZTogbnVtYmVyKSA9PiB7XG4gICAgaWYgKCFzdXBhYmFzZSkge1xuICAgICAgY29uc29sZS5lcnJvcignU3VwYWJhc2Ugbm8gZXN0w6EgaW5pY2lhbGl6YWRvJylcbiAgICAgIHRocm93IG5ldyBFcnJvcignU3VwYWJhc2Ugbm8gZXN0w6EgaW5pY2lhbGl6YWRvJylcbiAgICB9XG5cbiAgICB0cnkge1xuICAgICAgLy8gMS4gVmVyaWZpY2FyIGF1dGVudGljYWNpw7NuXG4gICAgICBjb25zdCB7IGRhdGE6IHsgdXNlciB9LCBlcnJvcjogdXNlckVycm9yIH0gPSBhd2FpdCBzdXBhYmFzZS5hdXRoLmdldFVzZXIoKVxuICAgICAgaWYgKHVzZXJFcnJvcikge1xuICAgICAgICBjb25zb2xlLmVycm9yKCdFcnJvciBhbCBvYnRlbmVyIHVzdWFyaW86JywgdXNlckVycm9yKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0Vycm9yIGFsIG9idGVuZXIgdXN1YXJpbycpXG4gICAgICB9XG4gICAgICBpZiAoIXVzZXIpIHtcbiAgICAgICAgY29uc29sZS5lcnJvcignTm8gaGF5IHVzdWFyaW8gYXV0ZW50aWNhZG8nKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ05vIGhheSB1c3VhcmlvIGF1dGVudGljYWRvJylcbiAgICAgIH1cblxuICAgICAgY29uc29sZS5sb2coJ0ludGVudGFuZG8gYWN0dWFsaXphciB2YWxvciBkZWwgZMOzbGFyOicsIHsgdXNlcl9pZDogdXNlci5pZCwgbW9udGgsIHZhbHVlIH0pXG5cbiAgICAgIC8vIEludGVudGFyIGFjdHVhbGl6YXIgcHJpbWVyb1xuICAgICAgY29uc3QgeyBkYXRhOiB1cGRhdGVEYXRhLCBlcnJvcjogdXBkYXRlRXJyb3IgfSA9IGF3YWl0IHN1cGFiYXNlXG4gICAgICAgIC5mcm9tKCdkb2xsYXJfdmFsdWVzJylcbiAgICAgICAgLnVwZGF0ZSh7IHZhbHVlIH0pXG4gICAgICAgIC5lcSgndXNlcl9pZCcsIHVzZXIuaWQpXG4gICAgICAgIC5lcSgnbW9udGgnLCBtb250aClcbiAgICAgICAgLnNlbGVjdCgpXG4gICAgICAgIC5zaW5nbGUoKVxuXG4gICAgICBpZiAodXBkYXRlRXJyb3IgJiYgdXBkYXRlRXJyb3IuY29kZSA9PT0gJ1BHUlNUMTE2Jykge1xuICAgICAgICBjb25zb2xlLmxvZygnUmVnaXN0cm8gbm8gZW5jb250cmFkbywgaW50ZW50YW5kbyBpbnNlcnRhci4uLicpXG4gICAgICAgIGNvbnN0IHsgZGF0YTogaW5zZXJ0RGF0YSwgZXJyb3I6IGluc2VydEVycm9yIH0gPSBhd2FpdCBzdXBhYmFzZVxuICAgICAgICAgIC5mcm9tKCdkb2xsYXJfdmFsdWVzJylcbiAgICAgICAgICAuaW5zZXJ0KHtcbiAgICAgICAgICAgIHVzZXJfaWQ6IHVzZXIuaWQsXG4gICAgICAgICAgICBtb250aCxcbiAgICAgICAgICAgIHZhbHVlLFxuICAgICAgICAgIH0pXG4gICAgICAgICAgLnNlbGVjdCgpXG4gICAgICAgICAgLnNpbmdsZSgpXG5cbiAgICAgICAgaWYgKGluc2VydEVycm9yKSB7XG4gICAgICAgICAgY29uc29sZS5lcnJvcignRXJyb3IgYWwgaW5zZXJ0YXI6JywgaW5zZXJ0RXJyb3IpXG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBFcnJvciBhbCBpbnNlcnRhcjogJHtpbnNlcnRFcnJvci5tZXNzYWdlfWApXG4gICAgICAgIH1cblxuICAgICAgICBzZXREb2xsYXJWYWx1ZXMocHJldiA9PiB7XG4gICAgICAgICAgY29uc3QgbmV3VmFsdWVzID0gWy4uLnByZXZdXG4gICAgICAgICAgY29uc3QgaW5kZXggPSBuZXdWYWx1ZXMuZmluZEluZGV4KGQgPT4gZC5tb250aCA9PT0gbW9udGgpXG4gICAgICAgICAgaWYgKGluZGV4ID49IDApIHtcbiAgICAgICAgICAgIG5ld1ZhbHVlc1tpbmRleF0gPSBpbnNlcnREYXRhXG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIG5ld1ZhbHVlcy5wdXNoKGluc2VydERhdGEpXG4gICAgICAgICAgfVxuICAgICAgICAgIGxvY2FsU3RvcmFnZS5zZXRJdGVtKGBkb2xsYXItdmFsdWVzLSR7c3RvcmFnZUlkfWAsIEpTT04uc3RyaW5naWZ5KG5ld1ZhbHVlcykpXG4gICAgICAgICAgcmV0dXJuIG5ld1ZhbHVlc1xuICAgICAgICB9KVxuICAgICAgICByZXR1cm4gaW5zZXJ0RGF0YVxuICAgICAgfVxuXG4gICAgICBpZiAodXBkYXRlRXJyb3IpIHtcbiAgICAgICAgY29uc29sZS5lcnJvcignRXJyb3IgYWwgYWN0dWFsaXphcjonLCB1cGRhdGVFcnJvcilcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBFcnJvciBhbCBhY3R1YWxpemFyOiAke3VwZGF0ZUVycm9yLm1lc3NhZ2V9YClcbiAgICAgIH1cblxuICAgICAgc2V0RG9sbGFyVmFsdWVzKHByZXYgPT4ge1xuICAgICAgICBjb25zdCBuZXdWYWx1ZXMgPSBbLi4ucHJldl1cbiAgICAgICAgY29uc3QgaW5kZXggPSBuZXdWYWx1ZXMuZmluZEluZGV4KGQgPT4gZC5tb250aCA9PT0gbW9udGgpXG4gICAgICAgIGlmIChpbmRleCA+PSAwKSB7XG4gICAgICAgICAgbmV3VmFsdWVzW2luZGV4XSA9IHVwZGF0ZURhdGFcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBuZXdWYWx1ZXMucHVzaCh1cGRhdGVEYXRhKVxuICAgICAgICB9XG4gICAgICAgIGxvY2FsU3RvcmFnZS5zZXRJdGVtKGBkb2xsYXItdmFsdWVzLSR7c3RvcmFnZUlkfWAsIEpTT04uc3RyaW5naWZ5KG5ld1ZhbHVlcykpXG4gICAgICAgIHJldHVybiBuZXdWYWx1ZXNcbiAgICAgIH0pXG4gICAgICByZXR1cm4gdXBkYXRlRGF0YVxuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBjb25zb2xlLmVycm9yKCdFcnJvciBhbCBhY3R1YWxpemFyIGVsIHZhbG9yIGRlbCBkw7NsYXI6JywgZXJyb3IpXG4gICAgICB0aHJvdyBlcnJvclxuICAgIH1cbiAgfVxuXG4gIHJldHVybiAoXG4gICAgPFRyYW5zYWN0aW9uQ29udGV4dC5Qcm92aWRlclxuICAgICAgdmFsdWU9e3tcbiAgICAgICAgdHJhbnNhY3Rpb25zLFxuICAgICAgICBkb2xsYXJWYWx1ZXMsXG4gICAgICAgIGFkZFRyYW5zYWN0aW9uLFxuICAgICAgICB1cGRhdGVUcmFuc2FjdGlvbixcbiAgICAgICAgZGVsZXRlVHJhbnNhY3Rpb24sXG4gICAgICAgIGdldE1vbnRoVHJhbnNhY3Rpb25zLFxuICAgICAgICBnZXRNb250aFN1bW1hcnksXG4gICAgICAgIGdldExhc3RTaXhNb250aHNTdW1tYXJ5LFxuICAgICAgICBnZXRBbGxNb250aHNTdW1tYXJ5LFxuICAgICAgICBnZXREb2xsYXJWYWx1ZSxcbiAgICAgICAgdXBkYXRlRG9sbGFyVmFsdWUsXG4gICAgICAgIGdldE1vbnRoQ2F0ZWdvcnlTdW1tYXJ5LFxuICAgICAgICBpc0xvYWRpbmcsXG4gICAgICB9fVxuICAgID5cbiAgICAgIHtjaGlsZHJlbn1cbiAgICA8L1RyYW5zYWN0aW9uQ29udGV4dC5Qcm92aWRlcj5cbiAgKVxufVxuXG5leHBvcnQgZnVuY3Rpb24gdXNlVHJhbnNhY3Rpb25zKCkge1xuICBjb25zdCBjb250ZXh0ID0gdXNlQ29udGV4dChUcmFuc2FjdGlvbkNvbnRleHQpXG4gIGlmIChjb250ZXh0ID09PSB1bmRlZmluZWQpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJ1c2VUcmFuc2FjdGlvbnMgbXVzdCBiZSB1c2VkIHdpdGhpbiBhIFRyYW5zYWN0aW9uUHJvdmlkZXJcIilcbiAgfVxuICByZXR1cm4gY29udGV4dFxufVxuIl0sIm5hbWVzIjpbImNyZWF0ZUNvbnRleHQiLCJ1c2VDb250ZXh0IiwidXNlRWZmZWN0IiwidXNlU3RhdGUiLCJ1c2VJZCIsInVzZU9wdGltaXN0aWMiLCJ1c2VUb2FzdCIsInVzZVN1cGFiYXNlIiwiZm9ybWF0Iiwic3ViTW9udGhzIiwiVHJhbnNhY3Rpb25Db250ZXh0IiwidW5kZWZpbmVkIiwiVHJhbnNhY3Rpb25Qcm92aWRlciIsImNoaWxkcmVuIiwic3VwYWJhc2UiLCJ0cmFuc2FjdGlvbnMiLCJzZXRUcmFuc2FjdGlvbnMiLCJkb2xsYXJWYWx1ZXMiLCJzZXREb2xsYXJWYWx1ZXMiLCJpc0xvYWRpbmciLCJzZXRJc0xvYWRpbmciLCJvcHRpbWlzdGljVHJhbnNhY3Rpb25zIiwiYWRkT3B0aW1pc3RpY1RyYW5zYWN0aW9uIiwic3RhdGUiLCJhY3Rpb24iLCJkYXRhIiwibWFwIiwidCIsImlkIiwidHJhbnNhY3Rpb24iLCJmaWx0ZXIiLCJvcHRpbWlzdGljRG9sbGFyVmFsdWVzIiwiYWRkT3B0aW1pc3RpY0RvbGxhclZhbHVlIiwiZXhpc3RpbmdJbmRleCIsImZpbmRJbmRleCIsImQiLCJtb250aCIsInRvYXN0Iiwic3RvcmFnZUlkIiwiY2FjaGVkVHJhbnNhY3Rpb25zIiwibG9jYWxTdG9yYWdlIiwiZ2V0SXRlbSIsInBhcnNlZFRyYW5zYWN0aW9ucyIsIkpTT04iLCJwYXJzZSIsImUiLCJjb25zb2xlIiwiZXJyb3IiLCJjYWNoZWREb2xsYXJWYWx1ZXMiLCJsb2FkRGF0YSIsInVzZXIiLCJ1c2VyRXJyb3IiLCJhdXRoIiwiZ2V0VXNlciIsInRvZGF5IiwiRGF0ZSIsIm1vbnRocyIsImkiLCJwdXNoIiwibG9nIiwidHJhbnNhY3Rpb25zRGF0YSIsInRyYW5zYWN0aW9uc0Vycm9yIiwiZnJvbSIsInNlbGVjdCIsImVxIiwiZ3RlIiwibGVuZ3RoIiwibHRlIiwib3JkZXIiLCJhc2NlbmRpbmciLCJzZXRJdGVtIiwic3RyaW5naWZ5IiwibG9hZERvbGxhclZhbHVlcyIsInRpdGxlIiwiZGVzY3JpcHRpb24iLCJFcnJvciIsIm1lc3NhZ2UiLCJ2YXJpYW50IiwiYWRkVHJhbnNhY3Rpb24iLCJleHBlbnNlVG9JbnNlcnQiLCJhbW91bnQiLCJkYXRlIiwiY2F0ZWdvcnlfaWQiLCJ1c2VyX2lkIiwidHlwZSIsImluc2VydCIsInNpbmdsZSIsInVwZGF0ZVRyYW5zYWN0aW9uIiwiZXhwZW5zZVRvVXBkYXRlIiwidXBkYXRlIiwiZGVsZXRlVHJhbnNhY3Rpb24iLCJkZWxldGUiLCJnZXRNb250aFRyYW5zYWN0aW9ucyIsInN0YXJ0c1dpdGgiLCJnZXRNb250aFN1bW1hcnkiLCJtb250aFRyYW5zYWN0aW9ucyIsImluY29tZSIsInJlZHVjZSIsInN1bSIsImV4cGVuc2UiLCJiYWxhbmNlIiwiZ2V0TW9udGhDYXRlZ29yeVN1bW1hcnkiLCJjYXRlZ29yeVN1bW1hcnkiLCJmb3JFYWNoIiwiT2JqZWN0IiwiZW50cmllcyIsImNhdGVnb3J5Iiwic29ydCIsImEiLCJiIiwiZ2V0TGFzdFNpeE1vbnRoc1N1bW1hcnkiLCJnZXRGdWxsWWVhciIsImdldE1vbnRoIiwiU3RyaW5nIiwicGFkU3RhcnQiLCJyZXZlcnNlIiwiZ2V0QWxsTW9udGhzU3VtbWFyeSIsIkFycmF5IiwiU2V0Iiwic3Vic3RyaW5nIiwibG9jYWxlQ29tcGFyZSIsIk51bWJlciIsImdldERvbGxhclZhbHVlIiwiZmluZCIsInVwZGF0ZURvbGxhclZhbHVlIiwidmFsdWUiLCJ1cGRhdGVEYXRhIiwidXBkYXRlRXJyb3IiLCJjb2RlIiwiaW5zZXJ0RGF0YSIsImluc2VydEVycm9yIiwicHJldiIsIm5ld1ZhbHVlcyIsImluZGV4IiwiUHJvdmlkZXIiLCJ1c2VUcmFuc2FjdGlvbnMiLCJjb250ZXh0Il0sImlnbm9yZUxpc3QiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./context/transaction-context.tsx\n"));

/***/ })

});