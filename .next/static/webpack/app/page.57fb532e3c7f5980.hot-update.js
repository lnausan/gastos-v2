"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/page",{

/***/ "(app-pages-browser)/./context/transaction-context.tsx":
/*!*****************************************!*\
  !*** ./context/transaction-context.tsx ***!
  \*****************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   TransactionProvider: () => (/* binding */ TransactionProvider),\n/* harmony export */   useTransactions: () => (/* binding */ useTransactions)\n/* harmony export */ });\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-dev-runtime */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/jsx-dev-runtime.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var _components_ui_use_toast__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @/components/ui/use-toast */ \"(app-pages-browser)/./components/ui/use-toast.ts\");\n/* harmony import */ var _components_providers_supabase_provider__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @/components/providers/supabase-provider */ \"(app-pages-browser)/./components/providers/supabase-provider.tsx\");\n/* harmony import */ var _barrel_optimize_names_format_subMonths_date_fns__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! __barrel_optimize__?names=format,subMonths!=!date-fns */ \"(app-pages-browser)/./node_modules/date-fns/subMonths.mjs\");\n/* harmony import */ var _barrel_optimize_names_format_subMonths_date_fns__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! __barrel_optimize__?names=format,subMonths!=!date-fns */ \"(app-pages-browser)/./node_modules/date-fns/format.mjs\");\n/* __next_internal_client_entry_do_not_use__ TransactionProvider,useTransactions auto */ \nvar _s = $RefreshSig$(), _s1 = $RefreshSig$();\n\n\n\n\nconst TransactionContext = /*#__PURE__*/ (0,react__WEBPACK_IMPORTED_MODULE_1__.createContext)(undefined);\nfunction TransactionProvider(param) {\n    let { children } = param;\n    _s();\n    const { supabase } = (0,_components_providers_supabase_provider__WEBPACK_IMPORTED_MODULE_3__.useSupabase)();\n    const [transactions, setTransactions] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)([]);\n    const [dollarValues, setDollarValues] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)([]);\n    const [isLoading, setIsLoading] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(true);\n    const [optimisticTransactions, addOptimisticTransaction] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useOptimistic)(transactions, {\n        \"TransactionProvider.useOptimistic\": (state, param)=>{\n            let { action, data } = param;\n            if (action === \"add\") {\n                return [\n                    ...state,\n                    data\n                ];\n            } else if (action === \"update\") {\n                return state.map({\n                    \"TransactionProvider.useOptimistic\": (t)=>t.id === data.id ? {\n                            ...t,\n                            ...data.transaction\n                        } : t\n                }[\"TransactionProvider.useOptimistic\"]);\n            } else if (action === \"delete\") {\n                return state.filter({\n                    \"TransactionProvider.useOptimistic\": (t)=>t.id !== data.id\n                }[\"TransactionProvider.useOptimistic\"]);\n            }\n            return state;\n        }\n    }[\"TransactionProvider.useOptimistic\"]);\n    const [optimisticDollarValues, addOptimisticDollarValue] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useOptimistic)(dollarValues, {\n        \"TransactionProvider.useOptimistic\": (state, param)=>{\n            let { action, data } = param;\n            if (action === \"update\") {\n                const existingIndex = state.findIndex({\n                    \"TransactionProvider.useOptimistic.existingIndex\": (d)=>d.month === data.month\n                }[\"TransactionProvider.useOptimistic.existingIndex\"]);\n                if (existingIndex >= 0) {\n                    return state.map({\n                        \"TransactionProvider.useOptimistic\": (d)=>d.month === data.month ? data : d\n                    }[\"TransactionProvider.useOptimistic\"]);\n                } else {\n                    return [\n                        ...state,\n                        data\n                    ];\n                }\n            }\n            return state;\n        }\n    }[\"TransactionProvider.useOptimistic\"]);\n    const { toast } = (0,_components_ui_use_toast__WEBPACK_IMPORTED_MODULE_2__.useToast)();\n    const storageId = (0,react__WEBPACK_IMPORTED_MODULE_1__.useId)();\n    // Cargar transacciones y valores del dólar desde localStorage al iniciar\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)({\n        \"TransactionProvider.useEffect\": ()=>{\n            if (!supabase) return;\n            // 1. Cargar datos de localStorage primero\n            const cachedTransactions = localStorage.getItem(\"transactions-\".concat(storageId));\n            if (cachedTransactions) {\n                try {\n                    const parsedTransactions = JSON.parse(cachedTransactions);\n                    setTransactions(parsedTransactions);\n                    setIsLoading(false) // Ya tenemos datos, no mostrar loading\n                    ;\n                } catch (e) {\n                    console.error('Error al parsear transacciones del localStorage:', e);\n                }\n            }\n            const cachedDollarValues = localStorage.getItem(\"dollar-values-\".concat(storageId));\n            if (cachedDollarValues) {\n                try {\n                    setDollarValues(JSON.parse(cachedDollarValues));\n                } catch (e) {\n                    console.error('Error al parsear valores del dólar del localStorage:', e);\n                }\n            }\n            // 2. Luego cargar desde Supabase en segundo plano\n            const loadData = {\n                \"TransactionProvider.useEffect.loadData\": async ()=>{\n                    try {\n                        const { data: { user }, error: userError } = await supabase.auth.getUser();\n                        if (userError) {\n                            console.error('Error al obtener usuario:', userError);\n                            throw userError;\n                        }\n                        if (!user) {\n                            console.error('No hay usuario autenticado');\n                            return;\n                        }\n                        // Calcular los últimos 6 meses\n                        const today = new Date();\n                        const months = [];\n                        for(let i = 0; i < 6; i++){\n                            const d = (0,_barrel_optimize_names_format_subMonths_date_fns__WEBPACK_IMPORTED_MODULE_4__.subMonths)(today, i);\n                            months.push((0,_barrel_optimize_names_format_subMonths_date_fns__WEBPACK_IMPORTED_MODULE_5__.format)(d, \"yyyy-MM\"));\n                        }\n                        console.log('Buscando transacciones para los meses:', months);\n                        // Traer solo las transacciones de los últimos 6 meses\n                        const { data: transactionsData, error: transactionsError } = await supabase.from('expenses').select('*').eq('user_id', user.id).gte('date', \"\".concat(months[months.length - 1], \"-01\")).lte('date', \"\".concat(months[0], \"-31\")).order('created_at', {\n                            ascending: false\n                        });\n                        if (transactionsError) {\n                            console.error('Error al cargar transacciones:', transactionsError);\n                            throw transactionsError;\n                        }\n                        if (transactionsData) {\n                            console.log('Transacciones cargadas:', transactionsData.length);\n                            setTransactions(transactionsData);\n                            localStorage.setItem(\"transactions-\".concat(storageId), JSON.stringify(transactionsData));\n                        }\n                        console.log('Buscando valores del dólar para los meses:', months);\n                        // Traer todos los valores del dólar del usuario\n                        const loadDollarValues = {\n                            \"TransactionProvider.useEffect.loadData.loadDollarValues\": async ()=>{\n                                if (!supabase) {\n                                    console.error('Supabase no está inicializado');\n                                    return;\n                                }\n                                try {\n                                    // 1. Verificar autenticación\n                                    const { data: { user }, error: userError } = await supabase.auth.getUser();\n                                    if (userError) {\n                                        console.error('Error al obtener usuario:', userError);\n                                        return;\n                                    }\n                                    if (!user) {\n                                        console.error('No hay usuario autenticado');\n                                        return;\n                                    }\n                                    console.log('Cargando historial de valores del dólar para usuario:', user.id);\n                                    // 2. Cargar todos los valores históricos\n                                    const { data, error } = await supabase.from('dollar_values').select('*').eq('user_id', user.id).order('month', {\n                                        ascending: false\n                                    });\n                                    console.log('Respuesta de la carga de dólares:', {\n                                        data,\n                                        error\n                                    });\n                                    if (error) {\n                                        console.error('Error al cargar valores del dólar:', error);\n                                        return;\n                                    }\n                                    if (!data) {\n                                        console.log('No se encontraron valores del dólar');\n                                        setDollarValues([]);\n                                        localStorage.setItem(\"dollar-values-\".concat(storageId), JSON.stringify([]));\n                                        return;\n                                    }\n                                    console.log('Historial de valores del dólar cargados:', data);\n                                    setDollarValues(data);\n                                    localStorage.setItem(\"dollar-values-\".concat(storageId), JSON.stringify(data));\n                                } catch (error) {\n                                    console.error('Error inesperado al cargar valores del dólar:', error);\n                                    setDollarValues([]);\n                                    localStorage.setItem(\"dollar-values-\".concat(storageId), JSON.stringify([]));\n                                }\n                            }\n                        }[\"TransactionProvider.useEffect.loadData.loadDollarValues\"];\n                        // Ejecutar la carga de datos\n                        await loadDollarValues();\n                    } catch (error) {\n                        console.error('Error detallado al cargar datos:', error);\n                        // No mostrar el error al usuario si ya tenemos datos en localStorage\n                        if (transactions.length === 0) {\n                            toast({\n                                title: 'Error al cargar los datos',\n                                description: error instanceof Error ? error.message : 'Error desconocido',\n                                variant: 'destructive'\n                            });\n                        }\n                    } finally{\n                        setIsLoading(false);\n                    }\n                }\n            }[\"TransactionProvider.useEffect.loadData\"];\n            loadData();\n        }\n    }[\"TransactionProvider.useEffect\"], [\n        supabase\n    ]);\n    // Agregar una nueva transacción\n    const addTransaction = async (transaction)=>{\n        if (!supabase) return;\n        try {\n            const { data: { user } } = await supabase.auth.getUser();\n            if (!user) {\n                console.error('No se pudo obtener el usuario autenticado');\n                return;\n            }\n            const expenseToInsert = {\n                amount: transaction.amount,\n                description: transaction.description,\n                date: transaction.date,\n                category_id: transaction.category_id,\n                user_id: user.id,\n                type: transaction.type\n            };\n            console.log('Insertando en Supabase:', expenseToInsert);\n            const { data, error } = await supabase.from('expenses').insert([\n                expenseToInsert\n            ]).select().single();\n            console.log('Respuesta de Supabase:', {\n                data,\n                error\n            });\n            if (error) throw error;\n            // Recargar todas las transacciones para asegurar consistencia\n            const { data: transactionsData, error: transactionsError } = await supabase.from('expenses').select('*').eq('user_id', user.id).order('created_at', {\n                ascending: false\n            });\n            if (transactionsError) throw transactionsError;\n            console.log('Transacciones actualizadas:', transactionsData);\n            setTransactions(transactionsData || []);\n            toast({\n                title: 'Transacción agregada correctamente'\n            });\n        } catch (error) {\n            console.error('Error al agregar transacción:', error);\n            toast({\n                title: 'Error al agregar la transacción'\n            });\n            throw error;\n        }\n    };\n    // Actualizar una transacción existente\n    const updateTransaction = async (id, transaction)=>{\n        if (!supabase) return;\n        try {\n            // Adaptar los campos al esquema de expenses\n            const expenseToUpdate = {};\n            if (transaction.amount !== undefined) expenseToUpdate.amount = transaction.amount;\n            if (transaction.description !== undefined) expenseToUpdate.description = transaction.description;\n            if (transaction.date !== undefined) expenseToUpdate.date = transaction.date;\n            if (transaction.category_id !== undefined) expenseToUpdate.category_id = transaction.category_id;\n            if (transaction.type !== undefined) expenseToUpdate.type = transaction.type;\n            console.log('Actualizando transacción:', {\n                id,\n                ...expenseToUpdate\n            });\n            const { data, error } = await supabase.from('expenses').update(expenseToUpdate).eq('id', id).select().single();\n            if (error) throw error;\n            console.log('Transacción actualizada:', data);\n            // Recargar todas las transacciones para asegurar consistencia\n            const { data: transactionsData, error: transactionsError } = await supabase.from('expenses').select('*').order('created_at', {\n                ascending: false\n            });\n            if (transactionsError) throw transactionsError;\n            console.log('Transacciones actualizadas:', transactionsData);\n            setTransactions(transactionsData || []);\n            toast({\n                title: 'Transacción actualizada correctamente'\n            });\n        } catch (error) {\n            console.error('Error al actualizar transacción:', error);\n            toast({\n                title: 'Error al actualizar la transacción'\n            });\n            throw error;\n        }\n    };\n    // Eliminar una transacción\n    const deleteTransaction = async (id)=>{\n        if (!supabase) return;\n        try {\n            console.log('Eliminando transacción:', id);\n            const { error } = await supabase.from('expenses').delete().eq('id', id);\n            if (error) throw error;\n            // Recargar todas las transacciones para asegurar consistencia\n            const { data: transactionsData, error: transactionsError } = await supabase.from('expenses').select('*').order('created_at', {\n                ascending: false\n            });\n            if (transactionsError) throw transactionsError;\n            console.log('Transacciones actualizadas:', transactionsData);\n            setTransactions(transactionsData || []);\n            toast({\n                title: 'Transacción eliminada correctamente'\n            });\n        } catch (error) {\n            console.error('Error al eliminar transacción:', error);\n            toast({\n                title: 'Error al eliminar la transacción'\n            });\n            throw error;\n        }\n    };\n    // Obtener transacciones de un mes específico\n    const getMonthTransactions = (month)=>{\n        return transactions.filter((t)=>t.date.startsWith(month));\n    };\n    // Obtener resumen de un mes específico\n    const getMonthSummary = (month)=>{\n        const monthTransactions = getMonthTransactions(month);\n        const income = monthTransactions.filter((t)=>t.type === 'ingreso').reduce((sum, t)=>sum + t.amount, 0);\n        const expense = monthTransactions.filter((t)=>t.type === 'gasto').reduce((sum, t)=>sum + t.amount, 0);\n        return {\n            month,\n            income,\n            expense,\n            balance: income - expense\n        };\n    };\n    // Obtener resumen por categoría para un mes específico\n    const getMonthCategorySummary = (month, type)=>{\n        const monthTransactions = getMonthTransactions(month).filter((t)=>t.type === type);\n        const categorySummary = {};\n        monthTransactions.forEach((transaction)=>{\n            if (!categorySummary[transaction.category_id]) {\n                categorySummary[transaction.category_id] = 0;\n            }\n            categorySummary[transaction.category_id] += transaction.amount;\n        });\n        return Object.entries(categorySummary).map((param)=>{\n            let [category, amount] = param;\n            return {\n                category,\n                amount\n            };\n        }).sort((a, b)=>b.amount - a.amount);\n    };\n    // Obtener los últimos 6 meses para el gráfico de barras\n    const getLastSixMonthsSummary = ()=>{\n        const today = new Date();\n        const months = [];\n        for(let i = 0; i < 6; i++){\n            const d = new Date(today.getFullYear(), today.getMonth() - i, 1);\n            const month = \"\".concat(d.getFullYear(), \"-\").concat(String(d.getMonth() + 1).padStart(2, '0'));\n            months.push(month);\n        }\n        return months.map((month)=>getMonthSummary(month)).reverse();\n    };\n    // Obtener todos los meses del año actual para el gráfico de líneas\n    const getAllMonthsSummary = ()=>{\n        // Obtener todos los meses únicos de las transacciones\n        const months = Array.from(new Set(transactions.map((t)=>t.date.substring(0, 7)))).sort((a, b)=>b.localeCompare(a)) // Ordenar de más reciente a más antiguo\n        ;\n        return months.map((month)=>{\n            const monthTransactions = transactions.filter((t)=>t.date.startsWith(month));\n            const income = monthTransactions.filter((t)=>t.type === 'ingreso').reduce((sum, t)=>sum + Number(t.amount), 0);\n            const expense = monthTransactions.filter((t)=>t.type === 'gasto').reduce((sum, t)=>sum + Number(t.amount), 0);\n            return {\n                month,\n                income,\n                expense,\n                balance: income - expense\n            };\n        });\n    };\n    // Obtener el valor del dólar para un mes específico\n    const getDollarValue = (month)=>{\n        return dollarValues.find((d)=>d.month === month);\n    };\n    // Actualizar el valor del dólar para un mes específico\n    const updateDollarValue = async (month, value)=>{\n        if (!supabase) {\n            console.error('Supabase no está inicializado');\n            throw new Error('Supabase no está inicializado');\n        }\n        try {\n            // 1. Verificar autenticación\n            const { data: { user }, error: userError } = await supabase.auth.getUser();\n            if (userError) {\n                console.error('Error al obtener usuario:', userError);\n                throw new Error('Error al obtener usuario');\n            }\n            if (!user) {\n                console.error('No hay usuario autenticado');\n                throw new Error('No hay usuario autenticado');\n            }\n            console.log('Intentando actualizar valor del dólar:', {\n                user_id: user.id,\n                month,\n                value\n            });\n            // Intentar actualizar primero\n            const { data: updateData, error: updateError } = await supabase.from('dollar_values').update({\n                value\n            }).eq('user_id', user.id).eq('month', month).select().single();\n            // Si no existe el registro, intentar insertar\n            if (updateError && updateError.code === 'PGRST116') {\n                console.log('Registro no encontrado, intentando insertar...');\n                const { data: insertData, error: insertError } = await supabase.from('dollar_values').insert({\n                    user_id: user.id,\n                    month,\n                    value\n                }).select().single();\n                if (insertError) {\n                    console.error('Error al insertar:', insertError);\n                    throw new Error(\"Error al insertar: \".concat(insertError.message));\n                }\n                // Actualizar el estado local\n                setDollarValues((prev)=>{\n                    const newValues = [\n                        ...prev\n                    ];\n                    const index = newValues.findIndex((d)=>d.month === month);\n                    if (index >= 0) {\n                        newValues[index] = insertData;\n                    } else {\n                        newValues.push(insertData);\n                    }\n                    return newValues;\n                });\n                // Actualizar localStorage\n                localStorage.setItem(\"dollar-values-\".concat(storageId), JSON.stringify(dollarValues));\n                return insertData;\n            }\n            if (updateError) {\n                console.error('Error al actualizar:', updateError);\n                throw new Error(\"Error al actualizar: \".concat(updateError.message));\n            }\n            // Actualizar el estado local\n            setDollarValues((prev)=>{\n                const newValues = [\n                    ...prev\n                ];\n                const index = newValues.findIndex((d)=>d.month === month);\n                if (index >= 0) {\n                    newValues[index] = updateData;\n                } else {\n                    newValues.push(updateData);\n                }\n                return newValues;\n            });\n            // Actualizar localStorage\n            localStorage.setItem(\"dollar-values-\".concat(storageId), JSON.stringify(dollarValues));\n            return updateData;\n        } catch (error) {\n            console.error('Error al actualizar el valor del dólar:', error);\n            throw error;\n        }\n    };\n    return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(TransactionContext.Provider, {\n        value: {\n            transactions,\n            dollarValues,\n            addTransaction,\n            updateTransaction,\n            deleteTransaction,\n            getMonthTransactions,\n            getMonthSummary,\n            getLastSixMonthsSummary,\n            getAllMonthsSummary,\n            getDollarValue,\n            updateDollarValue,\n            getMonthCategorySummary,\n            isLoading\n        },\n        children: children\n    }, void 0, false, {\n        fileName: \"/Users/lnausan/Documents/Gastos V2/context/transaction-context.tsx\",\n        lineNumber: 515,\n        columnNumber: 5\n    }, this);\n}\n_s(TransactionProvider, \"BfKdZl4tHdqFexW0dynwWq34vGQ=\", false, function() {\n    return [\n        _components_providers_supabase_provider__WEBPACK_IMPORTED_MODULE_3__.useSupabase,\n        react__WEBPACK_IMPORTED_MODULE_1__.useOptimistic,\n        react__WEBPACK_IMPORTED_MODULE_1__.useOptimistic,\n        _components_ui_use_toast__WEBPACK_IMPORTED_MODULE_2__.useToast,\n        react__WEBPACK_IMPORTED_MODULE_1__.useId\n    ];\n});\n_c = TransactionProvider;\nfunction useTransactions() {\n    _s1();\n    const context = (0,react__WEBPACK_IMPORTED_MODULE_1__.useContext)(TransactionContext);\n    if (context === undefined) {\n        throw new Error(\"useTransactions must be used within a TransactionProvider\");\n    }\n    return context;\n}\n_s1(useTransactions, \"b9L3QQ+jgeyIrH0NfHrJ8nn7VMU=\");\nvar _c;\n$RefreshReg$(_c, \"TransactionProvider\");\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL2NvbnRleHQvdHJhbnNhY3Rpb24tY29udGV4dC50c3giLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7QUFJNkc7QUFFekQ7QUFDa0I7QUFFMUI7QUFrQjVDLE1BQU1VLG1DQUFxQlYsb0RBQWFBLENBQXFDVztBQUV0RSxTQUFTQyxvQkFBb0IsS0FBMkM7UUFBM0MsRUFBRUMsUUFBUSxFQUFpQyxHQUEzQzs7SUFDbEMsTUFBTSxFQUFFQyxRQUFRLEVBQUUsR0FBR1Asb0ZBQVdBO0lBQ2hDLE1BQU0sQ0FBQ1EsY0FBY0MsZ0JBQWdCLEdBQUdiLCtDQUFRQSxDQUFnQixFQUFFO0lBQ2xFLE1BQU0sQ0FBQ2MsY0FBY0MsZ0JBQWdCLEdBQUdmLCtDQUFRQSxDQUFnQixFQUFFO0lBQ2xFLE1BQU0sQ0FBQ2dCLFdBQVdDLGFBQWEsR0FBR2pCLCtDQUFRQSxDQUFDO0lBRTNDLE1BQU0sQ0FBQ2tCLHdCQUF3QkMseUJBQXlCLEdBQUdqQixvREFBYUEsQ0FHdEVVOzZDQUFjLENBQUNRO2dCQUFPLEVBQUVDLE1BQU0sRUFBRUMsSUFBSSxFQUFFO1lBQ3RDLElBQUlELFdBQVcsT0FBTztnQkFDcEIsT0FBTzt1QkFBSUQ7b0JBQU9FO2lCQUFLO1lBQ3pCLE9BQU8sSUFBSUQsV0FBVyxVQUFVO2dCQUM5QixPQUFPRCxNQUFNRyxHQUFHO3lEQUFDLENBQUNDLElBQU9BLEVBQUVDLEVBQUUsS0FBS0gsS0FBS0csRUFBRSxHQUFHOzRCQUFFLEdBQUdELENBQUM7NEJBQUUsR0FBR0YsS0FBS0ksV0FBVzt3QkFBQyxJQUFJRjs7WUFDOUUsT0FBTyxJQUFJSCxXQUFXLFVBQVU7Z0JBQzlCLE9BQU9ELE1BQU1PLE1BQU07eURBQUMsQ0FBQ0gsSUFBTUEsRUFBRUMsRUFBRSxLQUFLSCxLQUFLRyxFQUFFOztZQUM3QztZQUNBLE9BQU9MO1FBQ1Q7O0lBRUEsTUFBTSxDQUFDUSx3QkFBd0JDLHlCQUF5QixHQUFHM0Isb0RBQWFBLENBR3RFWTs2Q0FBYyxD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LFNBQVMsQ0FBQ0MsTUFBTSxHQUFHUDtnQkFDckIsT0FBTztvQkFDTE0sVUFBVTFFLElBQUksQ0FBQ29FO2dCQUNqQjtnQkFDQSxPQUFPTTtZQUNUO1lBRUEsMEJBQTBCO1lBQzFCNUYsYUFBYThCLE9BQU8sQ0FBQyxpQkFBMkIsT0FBVmhDLFlBQWFLLEtBQUs0QixTQUFTLENBQUN0RDtZQUVsRSxPQUFPNkc7UUFDVCxFQUFFLE9BQU8vRSxPQUFPO1lBQ2RELFFBQVFDLEtBQUssQ0FBQywyQ0FBMkNBO1lBQ3pELE1BQU1BO1FBQ1I7SUFDRjtJQUVBLHFCQUNFLDhEQUFDckMsbUJBQW1CNEgsUUFBUTtRQUMxQlQsT0FBTztZQUNMOUc7WUFDQUU7WUFDQTZEO1lBQ0FTO1lBQ0FHO1lBQ0FFO1lBQ0FFO1lBQ0FnQjtZQUNBTTtZQUNBTTtZQUNBRTtZQUNBdkI7WUFDQWxGO1FBQ0Y7a0JBRUNOOzs7Ozs7QUFHUDtHQXpmZ0JEOztRQUNPTCxnRkFBV0E7UUFLMkJGLGdEQUFhQTtRQWNiQSxnREFBYUE7UUFldERDLDhEQUFRQTtRQUNSRix3Q0FBS0E7OztLQXBDVFE7QUEyZlQsU0FBUzJIOztJQUNkLE1BQU1DLFVBQVV2SSxpREFBVUEsQ0FBQ1M7SUFDM0IsSUFBSThILFlBQVk3SCxXQUFXO1FBQ3pCLE1BQU0sSUFBSWdFLE1BQU07SUFDbEI7SUFDQSxPQUFPNkQ7QUFDVDtJQU5nQkQiLCJzb3VyY2VzIjpbIi9Vc2Vycy9sbmF1c2FuL0RvY3VtZW50cy9HYXN0b3MgVjIvY29udGV4dC90cmFuc2FjdGlvbi1jb250ZXh0LnRzeCJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBjbGllbnRcIlxuXG5pbXBvcnQgdHlwZSBSZWFjdCBmcm9tIFwicmVhY3RcIlxuXG5pbXBvcnQgeyBjcmVhdGVDb250ZXh0LCB1c2VDb250ZXh0LCB1c2VFZmZlY3QsIHVzZVN0YXRlLCB1c2VJZCwgdXNlT3B0aW1pc3RpYywgc3RhcnRUcmFuc2l0aW9uIH0gZnJvbSBcInJlYWN0XCJcbmltcG9ydCB0eXBlIHsgVHJhbnNhY3Rpb24sIE1vbnRoU3VtbWFyeSwgRG9sbGFyVmFsdWUgfSBmcm9tIFwiQC90eXBlcy90cmFuc2FjdGlvblwiXG5pbXBvcnQgeyB1c2VUb2FzdCB9IGZyb20gXCJAL2NvbXBvbmVudHMvdWkvdXNlLXRvYXN0XCJcbmltcG9ydCB7IHVzZVN1cGFiYXNlIH0gZnJvbSAnQC9jb21wb25lbnRzL3Byb3ZpZGVycy9zdXBhYmFzZS1wcm92aWRlcidcbmltcG9ydCB7IHRvYXN0IH0gZnJvbSAnc29ubmVyJ1xuaW1wb3J0IHsgZm9ybWF0LCBzdWJNb250aHMgfSBmcm9tIFwiZGF0ZS1mbnNcIlxuXG5pbnRlcmZhY2UgVHJhbnNhY3Rpb25Db250ZXh0VHlwZSB7XG4gIHRyYW5zYWN0aW9uczogVHJhbnNhY3Rpb25bXVxuICBkb2xsYXJWYWx1ZXM6IERvbGxhclZhbHVlW11cbiAgYWRkVHJhbnNhY3Rpb246ICh0cmFuc2FjdGlvbjogT21pdDxUcmFuc2FjdGlvbiwgXCJpZFwiIHwgXCJjcmVhdGVkX2F0XCIgfCBcInVwZGF0ZWRfYXRcIiB8IFwidXNlcl9pZFwiPikgPT4gUHJvbWlzZTx2b2lkPlxuICB1cGRhdGVUcmFuc2FjdGlvbjogKGlkOiBzdHJpbmcsIHRyYW5zYWN0aW9uOiBQYXJ0aWFsPFRyYW5zYWN0aW9uPikgPT4gUHJvbWlzZTx2b2lkPlxuICBkZWxldGVUcmFuc2FjdGlvbjogKGlkOiBzdHJpbmcpID0+IFByb21pc2U8dm9pZD5cbiAgZ2V0TW9udGhUcmFuc2FjdGlvbnM6IChtb250aDogc3RyaW5nKSA9PiBUcmFuc2FjdGlvbltdXG4gIGdldE1vbnRoU3VtbWFyeTogKG1vbnRoOiBzdHJpbmcpID0+IE1vbnRoU3VtbWFyeVxuICBnZXRMYXN0U2l4TW9udGhzU3VtbWFyeTogKCkgPT4gTW9udGhTdW1tYXJ5W11cbiAgZ2V0QWxsTW9udGhzU3VtbWFyeTogKCkgPT4gTW9udGhTdW1tYXJ5W11cbiAgZ2V0RG9sbGFyVmFsdWU6IChtb250aDogc3RyaW5nKSA9PiBEb2xsYXJWYWx1ZSB8IHVuZGVmaW5lZFxuICB1cGRhdGVEb2xsYXJWYWx1ZTogKG1vbnRoOiBzdHJpbmcsIHZhbHVlOiBudW1iZXIpID0+IFByb21pc2U8dm9pZD5cbiAgZ2V0TW9udGhDYXRlZ29yeVN1bW1hcnk6IChtb250aDogc3RyaW5nLCB0eXBlOiBcImluZ3Jlc29cIiB8IFwiZ2FzdG9cIikgPT4geyBjYXRlZ29yeTogc3RyaW5nOyBhbW91bnQ6IG51bWJlciB9W11cbiAgaXNMb2FkaW5nOiBib29sZWFuXG59XG5cbmNvbnN0IFRyYW5zYWN0aW9uQ29udGV4dCA9IGNyZWF0ZUNvbnRleHQ8VHJhbnNhY3Rpb25Db250ZXh0VHlwZSB8IHVuZGVmaW5lZD4odW5kZWZpbmVkKVxuXG5leHBvcnQgZnVuY3Rpb24gVHJhbnNhY3Rpb25Qcm92aWRlcih7IGNoaWxkcmVuIH06IHsgY2hpbGRyZW46IFJlYWN0LlJlYWN0Tm9kZSB9KSB7XG4gIGNvbnN0IHsgc3VwYWJhc2UgfSA9IHVzZVN1cGFiYXNlKClcbiAgY29uc3QgW3RyYW5zYWN0aW9ucywgc2V0VHJhbnNhY3Rpb25zXSA9IHVzZVN0YXRlPFRyYW5zYWN0aW9uW10+KFtdKVxuICBjb25zdCBbZG9sbGFyVmFsdWVzLCBzZXREb2xsYXJWYWx1ZXNdID0gdXNlU3RhdGU8RG9sbGFyVmFsdWVbXT4oW10pXG4gIGNvbnN0IFtpc0xvYWRpbmcsIHNldElzTG9hZGluZ10gPSB1c2VTdGF0ZSh0cnVlKVxuXG4gIGNvbnN0IFtvcHRpbWlzdGljVHJhbnNhY3Rpb25zLCBhZGRPcHRpbWlzdGljVHJhbnNhY3Rpb25dID0gdXNlT3B0aW1pc3RpYzxcbiAgICBUcmFuc2FjdGlvbltdLFxuICAgIHsgYWN0aW9uOiBcImFkZFwiIHwgXCJ1cGRhdGVcIiB8IFwiZGVsZXRlXCI7IGRhdGE6IGFueSB9XG4gID4odHJhbnNhY3Rpb25zLCAoc3RhdGUsIHsgYWN0aW9uLCBkYXRhIH0pID0+IHtcbiAgICBpZiAoYWN0aW9uID09PSBcImFkZFwiKSB7XG4gICAgICByZXR1cm4gWy4uLnN0YXRlLCBkYXRhXVxuICAgIH0gZWxzZSBpZiAoYWN0aW9uID09PSBcInVwZGF0ZVwiKSB7XG4gICAgICByZXR1cm4gc3RhdGUubWFwKCh0KSA9PiAodC5pZCA9PT0gZGF0YS5pZCA/IHsgLi4udCwgLi4uZGF0YS50cmFuc2FjdGlvbiB9IDogdCkpXG4gICAgfSBlbHNlIGlmIChhY3Rpb24gPT09IFwiZGVsZXRlXCIpIHtcbiAgICAgIHJldHVybiBzdGF0ZS5maWx0ZXIoKHQpID0+IHQuaWQgIT09IGRhdGEuaWQpXG4gICAgfVxuICAgIHJldHVybiBzdGF0ZVxuICB9KVxuXG4gIGNvbnN0IFtvcHRpbWlzdGljRG9sbGFyVmFsdWVzLCBhZGRPcHRpbWlzdGljRG9sbGFyVmFsdWVdID0gdXNlT3B0aW1pc3RpYzxcbiAgICBEb2xsYXJWYWx1ZVtdLFxuICAgIHsgYWN0aW9uOiBcInVwZGF0ZVwiOyBkYXRhOiBhbnkgfVxuICA+KGRvbGxhclZhbHVlcywgKHN0YXRlLCB7IGFjdGlvbiwgZGF0YSB9KSA9PiB7XG4gICAgaWYgKGFjdGlvbiA9PT0gXCJ1cGRhdGVcIikge1xuICAgICAgY29uc3QgZXhpc3RpbmdJbmRleCA9IHN0YXRlLmZpbmRJbmRleCgoZCkgPT4gZC5tb250aCA9PT0gZGF0YS5tb250aClcbiAgICAgIGlmIChleGlzdGluZ0luZGV4ID49IDApIHtcbiAgICAgICAgcmV0dXJuIHN0YXRlLm1hcCgoZCkgPT4gKGQubW9udGggPT09IGRhdGEubW9udGggPyBkYXRhIDogZCkpXG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gWy4uLnN0YXRlLCBkYXRhXVxuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gc3RhdGVcbiAgfSlcblxuICBjb25zdCB7IHRvYXN0IH0gPSB1c2VUb2FzdCgpXG4gIGNvbnN0IHN0b3JhZ2VJZCA9IHVzZUlkKClcblxuICAvLyBDYXJnYXIgdHJhbnNhY2Npb25lcyB5IHZhbG9yZXMgZGVsIGTDs2xhciBkZXNkZSBsb2NhbFN0b3JhZ2UgYWwgaW5pY2lhclxuICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgIGlmICghc3VwYWJhc2UpIHJldHVyblxuXG4gICAgLy8gMS4gQ2FyZ2FyIGRhdG9zIGRlIGxvY2FsU3RvcmFnZSBwcmltZXJvXG4gICAgY29uc3QgY2FjaGVkVHJhbnNhY3Rpb25zID0gbG9jYWxTdG9yYWdlLmdldEl0ZW0oYHRyYW5zYWN0aW9ucy0ke3N0b3JhZ2VJZH1gKVxuICAgIGlmIChjYWNoZWRUcmFuc2FjdGlvbnMpIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIGNvbnN0IHBhcnNlZFRyYW5zYWN0aW9ucyA9IEpTT04ucGFyc2UoY2FjaGVkVHJhbnNhY3Rpb25zKVxuICAgICAgICBzZXRUcmFuc2FjdGlvbnMocGFyc2VkVHJhbnNhY3Rpb25zKVxuICAgICAgICBzZXRJc0xvYWRpbmcoZmFsc2UpIC8vIFlhIHRlbmVtb3MgZGF0b3MsIG5vIG1vc3RyYXIgbG9hZGluZ1xuICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICBjb25zb2xlLmVycm9yKCdFcnJvciBhbCBwYXJzZWFyIHRyYW5zYWNjaW9uZXMgZGVsIGxvY2FsU3RvcmFnZTonLCBlKVxuICAgICAgfVxuICAgIH1cblxuICAgIGNvbnN0IGNhY2hlZERvbGxhclZhbHVlcyA9IGxvY2FsU3RvcmFnZS5nZXRJdGVtKGBkb2xsYXItdmFsdWVzLSR7c3RvcmFnZUlkfWApXG4gICAgaWYgKGNhY2hlZERvbGxhclZhbHVlcykge1xuICAgICAgdHJ5IHtcbiAgICAgICAgc2V0RG9sbGFyVmFsdWVzKEpTT04ucGFyc2UoY2FjaGVkRG9sbGFyVmFsdWVzKSlcbiAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgY29uc29sZS5lcnJvcignRXJyb3IgYWwgcGFyc2VhciB2YWxvcmVzIGRlbCBkw7NsYXIgZGVsIGxvY2FsU3RvcmFnZTonLCBlKVxuICAgICAgfVxuICAgIH1cblxuICAgIC8vIDIuIEx1ZWdvIGNhcmdhciBkZXNkZSBTdXBhYmFzZSBlbiBzZWd1bmRvIHBsYW5vXG4gICAgY29uc3QgbG9hZERhdGEgPSBhc3luYyAoKSA9PiB7XG4gICAgICB0cnkge1xuICAgICAgICBjb25zdCB7IGRhdGE6IHsgdXNlciB9LCBlcnJvcjogdXNlckVycm9yIH0gPSBhd2FpdCBzdXBhYmFzZS5hdXRoLmdldFVzZXIoKVxuICAgICAgICBpZiAodXNlckVycm9yKSB7XG4gICAgICAgICAgY29uc29sZS5lcnJvcignRXJyb3IgYWwgb2J0ZW5lciB1c3VhcmlvOicsIHVzZXJFcnJvcilcbiAgICAgICAgICB0aHJvdyB1c2VyRXJyb3JcbiAgICAgICAgfVxuICAgICAgICBpZiAoIXVzZXIpIHtcbiAgICAgICAgICBjb25zb2xlLmVycm9yKCdObyBoYXkgdXN1YXJpbyBhdXRlbnRpY2FkbycpXG4gICAgICAgICAgcmV0dXJuXG4gICAgICAgIH1cblxuICAgICAgICAvLyBDYWxjdWxhciBsb3Mgw7psdGltb3MgNiBtZXNlc1xuICAgICAgICBjb25zdCB0b2RheSA9IG5ldyBEYXRlKClcbiAgICAgICAgY29uc3QgbW9udGhzOiBzdHJpbmdbXSA9IFtdXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgNjsgaSsrKSB7XG4gICAgICAgICAgY29uc3QgZCA9IHN1Yk1vbnRocyh0b2RheSwgaSlcbiAgICAgICAgICBtb250aHMucHVzaChmb3JtYXQoZCwgXCJ5eXl5LU1NXCIpKVxuICAgICAgICB9XG5cbiAgICAgICAgY29uc29sZS5sb2coJ0J1c2NhbmRvIHRyYW5zYWNjaW9uZXMgcGFyYSBsb3MgbWVzZXM6JywgbW9udGhzKVxuXG4gICAgICAgIC8vIFRyYWVyIHNvbG8gbGFzIHRyYW5zYWNjaW9uZXMgZGUgbG9zIMO6bHRpbW9zIDYgbWVzZXNcbiAgICAgICAgY29uc3QgeyBkYXRhOiB0cmFuc2FjdGlvbnNEYXRhLCBlcnJvcjogdHJhbnNhY3Rpb25zRXJyb3IgfSA9IGF3YWl0IHN1cGFiYXNlXG4gICAgICAgICAgLmZyb20oJ2V4cGVuc2VzJylcbiAgICAgICAgICAuc2VsZWN0KCcqJylcbiAgICAgICAgICAuZXEoJ3VzZXJfaWQnLCB1c2VyLmlkKVxuICAgICAgICAgIC5ndGUoJ2RhdGUnLCBgJHttb250aHNbbW9udGhzLmxlbmd0aCAtIDFdfS0wMWApXG4gICAgICAgICAgLmx0ZSgnZGF0ZScsIGAke21vbnRoc1swXX0tMzFgKVxuICAgICAgICAgIC5vcmRlcignY3JlYXRlZF9hdCcsIHsgYXNjZW5kaW5nOiBmYWxzZSB9KVxuXG4gICAgICAgIGlmICh0cmFuc2FjdGlvbnNFcnJvcikge1xuICAgICAgICAgIGNvbnNvbGUuZXJyb3IoJ0Vycm9yIGFsIGNhcmdhciB0cmFuc2FjY2lvbmVzOicsIHRyYW5zYWN0aW9uc0Vycm9yKVxuICAgICAgICAgIHRocm93IHRyYW5zYWN0aW9uc0Vycm9yXG4gICAgICAgIH1cblxuICAgICAgICBpZiAodHJhbnNhY3Rpb25zRGF0YSkge1xuICAgICAgICAgIGNvbnNvbGUubG9nKCdUcmFuc2FjY2lvbmVzIGNhcmdhZGFzOicsIHRyYW5zYWN0aW9uc0RhdGEubGVuZ3RoKVxuICAgICAgICAgIHNldFRyYW5zYWN0aW9ucyh0cmFuc2FjdGlvbnNEYXRhKVxuICAgICAgICAgIGxvY2FsU3RvcmFnZS5zZXRJdGVtKGB0cmFuc2FjdGlvbnMtJHtzdG9yYWdlSWR9YCwgSlNPTi5zdHJpbmdpZnkodHJhbnNhY3Rpb25zRGF0YSkpXG4gICAgICAgIH1cblxuICAgICAgICBjb25zb2xlLmxvZygnQnVzY2FuZG8gdmFsb3JlcyBkZWwgZMOzbGFyIHBhcmEgbG9zIG1lc2VzOicsIG1vbnRocylcblxuICAgICAgICAvLyBUcmFlciB0b2RvcyBsb3MgdmFsb3JlcyBkZWwgZMOzbGFyIGRlbCB1c3VhcmlvXG4gICAgICAgIGNvbnN0IGxvYWREb2xsYXJWYWx1ZXMgPSBhc3luYyAoKSA9PiB7XG4gICAgICAgICAgaWYgKCFzdXBhYmFzZSkge1xuICAgICAgICAgICAgY29uc29sZS5lcnJvcignU3VwYWJhc2Ugbm8gZXN0w6EgaW5pY2lhbGl6YWRvJylcbiAgICAgICAgICAgIHJldHVyblxuICAgICAgICAgIH1cblxuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAvLyAxLiBWZXJpZmljYXIgYXV0ZW50aWNhY2nDs25cbiAgICAgICAgICAgIGNvbnN0IHsgZGF0YTogeyB1c2VyIH0sIGVycm9yOiB1c2VyRXJyb3IgfSA9IGF3YWl0IHN1cGFiYXNlLmF1dGguZ2V0VXNlcigpXG4gICAgICAgICAgICBpZiAodXNlckVycm9yKSB7XG4gICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoJ0Vycm9yIGFsIG9idGVuZXIgdXN1YXJpbzonLCB1c2VyRXJyb3IpXG4gICAgICAgICAgICAgIHJldHVyblxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCF1c2VyKSB7XG4gICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoJ05vIGhheSB1c3VhcmlvIGF1dGVudGljYWRvJylcbiAgICAgICAgICAgICAgcmV0dXJuXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGNvbnNvbGUubG9nKCdDYXJnYW5kbyBoaXN0b3JpYWwgZGUgdmFsb3JlcyBkZWwgZMOzbGFyIHBhcmEgdXN1YXJpbzonLCB1c2VyLmlkKVxuXG4gICAgICAgICAgICAvLyAyLiBDYXJnYXIgdG9kb3MgbG9zIHZhbG9yZXMgaGlzdMOzcmljb3NcbiAgICAgICAgICAgIGNvbnN0IHsgZGF0YSwgZXJyb3IgfSA9IGF3YWl0IHN1cGFiYXNlXG4gICAgICAgICAgICAgIC5mcm9tKCdkb2xsYXJfdmFsdWVzJylcbiAgICAgICAgICAgICAgLnNlbGVjdCgnKicpXG4gICAgICAgICAgICAgIC5lcSgndXNlcl9pZCcsIHVzZXIuaWQpXG4gICAgICAgICAgICAgIC5vcmRlcignbW9udGgnLCB7IGFzY2VuZGluZzogZmFsc2UgfSlcblxuICAgICAgICAgICAgY29uc29sZS5sb2coJ1Jlc3B1ZXN0YSBkZSBsYSBjYXJnYSBkZSBkw7NsYXJlczonLCB7IGRhdGEsIGVycm9yIH0pXG5cbiAgICAgICAgICAgIGlmIChlcnJvcikge1xuICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKCdFcnJvciBhbCBjYXJnYXIgdmFsb3JlcyBkZWwgZMOzbGFyOicsIGVycm9yKVxuICAgICAgICAgICAgICByZXR1cm5cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKCFkYXRhKSB7XG4gICAgICAgICAgICAgIGNvbnNvbGUubG9nKCdObyBzZSBlbmNvbnRyYXJvbiB2YWxvcmVzIGRlbCBkw7NsYXInKVxuICAgICAgICAgICAgICBzZXREb2xsYXJWYWx1ZXMoW10pXG4gICAgICAgICAgICAgIGxvY2FsU3RvcmFnZS5zZXRJdGVtKGBkb2xsYXItdmFsdWVzLSR7c3RvcmFnZUlkfWAsIEpTT04uc3RyaW5naWZ5KFtdKSlcbiAgICAgICAgICAgICAgcmV0dXJuXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGNvbnNvbGUubG9nKCdIaXN0b3JpYWwgZGUgdmFsb3JlcyBkZWwgZMOzbGFyIGNhcmdhZG9zOicsIGRhdGEpXG4gICAgICAgICAgICBzZXREb2xsYXJWYWx1ZXMoZGF0YSlcbiAgICAgICAgICAgIGxvY2FsU3RvcmFnZS5zZXRJdGVtKGBkb2xsYXItdmFsdWVzLSR7c3RvcmFnZUlkfWAsIEpTT04uc3RyaW5naWZ5KGRhdGEpKVxuXG4gICAgICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoJ0Vycm9yIGluZXNwZXJhZG8gYWwgY2FyZ2FyIHZhbG9yZXMgZGVsIGTDs2xhcjonLCBlcnJvcilcbiAgICAgICAgICAgIHNldERvbGxhclZhbHVlcyhbXSlcbiAgICAgICAgICAgIGxvY2FsU3RvcmFnZS5zZXRJdGVtKGBkb2xsYXItdmFsdWVzLSR7c3RvcmFnZUlkfWAsIEpTT04uc3RyaW5naWZ5KFtdKSlcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvLyBFamVjdXRhciBsYSBjYXJnYSBkZSBkYXRvc1xuICAgICAgICBhd2FpdCBsb2FkRG9sbGFyVmFsdWVzKClcbiAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoJ0Vycm9yIGRldGFsbGFkbyBhbCBjYXJnYXIgZGF0b3M6JywgZXJyb3IpXG4gICAgICAgIC8vIE5vIG1vc3RyYXIgZWwgZXJyb3IgYWwgdXN1YXJpbyBzaSB5YSB0ZW5lbW9zIGRhdG9zIGVuIGxvY2FsU3RvcmFnZVxuICAgICAgICBpZiAodHJhbnNhY3Rpb25zLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgIHRvYXN0KHtcbiAgICAgICAgICAgIHRpdGxlOiAnRXJyb3IgYWwgY2FyZ2FyIGxvcyBkYXRvcycsXG4gICAgICAgICAgICBkZXNjcmlwdGlvbjogZXJyb3IgaW5zdGFuY2VvZiBFcnJvciA/IGVycm9yLm1lc3NhZ2UgOiAnRXJyb3IgZGVzY29ub2NpZG8nLFxuICAgICAgICAgICAgdmFyaWFudDogJ2Rlc3RydWN0aXZlJ1xuICAgICAgICAgIH0pXG4gICAgICAgIH1cbiAgICAgIH0gZmluYWxseSB7XG4gICAgICAgIHNldElzTG9hZGluZyhmYWxzZSlcbiAgICAgIH1cbiAgICB9XG5cbiAgICBsb2FkRGF0YSgpXG4gIH0sIFtzdXBhYmFzZV0pXG5cbiAgLy8gQWdyZWdhciB1bmEgbnVldmEgdHJhbnNhY2Npw7NuXG4gIGNvbnN0IGFkZFRyYW5zYWN0aW9uID0gYXN5bmMgKHRyYW5zYWN0aW9uOiBPbWl0PFRyYW5zYWN0aW9uLCBcImlkXCIgfCBcImNyZWF0ZWRfYXRcIiB8IFwidXBkYXRlZF9hdFwiIHwgXCJ1c2VyX2lkXCI+KSA9PiB7XG4gICAgaWYgKCFzdXBhYmFzZSkgcmV0dXJuXG5cbiAgICB0cnkge1xuICAgICAgY29uc3QgeyBkYXRhOiB7IHVzZXIgfSB9ID0gYXdhaXQgc3VwYWJhc2UuYXV0aC5nZXRVc2VyKClcbiAgICAgIGlmICghdXNlcikge1xuICAgICAgICBjb25zb2xlLmVycm9yKCdObyBzZSBwdWRvIG9idGVuZXIgZWwgdXN1YXJpbyBhdXRlbnRpY2FkbycpXG4gICAgICAgIHJldHVyblxuICAgICAgfVxuXG4gICAgICBjb25zdCBleHBlbnNlVG9JbnNlcnQgPSB7XG4gICAgICAgIGFtb3VudDogdHJhbnNhY3Rpb24uYW1vdW50LFxuICAgICAgICBkZXNjcmlwdGlvbjogdHJhbnNhY3Rpb24uZGVzY3JpcHRpb24sXG4gICAgICAgIGRhdGU6IHRyYW5zYWN0aW9uLmRhdGUsXG4gICAgICAgIGNhdGVnb3J5X2lkOiB0cmFuc2FjdGlvbi5jYXRlZ29yeV9pZCxcbiAgICAgICAgdXNlcl9pZDogdXNlci5pZCxcbiAgICAgICAgdHlwZTogdHJhbnNhY3Rpb24udHlwZSxcbiAgICB9XG5cbiAgICAgIGNvbnNvbGUubG9nKCdJbnNlcnRhbmRvIGVuIFN1cGFiYXNlOicsIGV4cGVuc2VUb0luc2VydClcblxuICAgICAgY29uc3QgeyBkYXRhLCBlcnJvciB9ID0gYXdhaXQgc3VwYWJhc2VcbiAgICAgICAgLmZyb20oJ2V4cGVuc2VzJylcbiAgICAgICAgLmluc2VydChbZXhwZW5zZVRvSW5zZXJ0XSlcbiAgICAgICAgLnNlbGVjdCgpXG4gICAgICAgIC5zaW5nbGUoKVxuXG4gICAgICBjb25zb2xlLmxvZygnUmVzcHVlc3RhIGRlIFN1cGFiYXNlOicsIHsgZGF0YSwgZXJyb3IgfSlcblxuICAgICAgaWYgKGVycm9yKSB0aHJvdyBlcnJvclxuXG4gICAgICAvLyBSZWNhcmdhciB0b2RhcyBsYXMgdHJhbnNhY2Npb25lcyBwYXJhIGFzZWd1cmFyIGNvbnNpc3RlbmNpYVxuICAgICAgY29uc3QgeyBkYXRhOiB0cmFuc2FjdGlvbnNEYXRhLCBlcnJvcjogdHJhbnNhY3Rpb25zRXJyb3IgfSA9IGF3YWl0IHN1cGFiYXNlXG4gICAgICAgIC5mcm9tKCdleHBlbnNlcycpXG4gICAgICAgIC5zZWxlY3QoJyonKVxuICAgICAgICAuZXEoJ3VzZXJfaWQnLCB1c2VyLmlkKVxuICAgICAgICAub3JkZXIoJ2NyZWF0ZWRfYXQnLCB7IGFzY2VuZGluZzogZmFsc2UgfSlcblxuICAgICAgaWYgKHRyYW5zYWN0aW9uc0Vycm9yKSB0aHJvdyB0cmFuc2FjdGlvbnNFcnJvclxuXG4gICAgICBjb25zb2xlLmxvZygnVHJhbnNhY2Npb25lcyBhY3R1YWxpemFkYXM6JywgdHJhbnNhY3Rpb25zRGF0YSlcbiAgICAgIHNldFRyYW5zYWN0aW9ucyh0cmFuc2FjdGlvbnNEYXRhIHx8IFtdKVxuICAgICAgdG9hc3QoeyB0aXRsZTogJ1RyYW5zYWNjacOzbiBhZ3JlZ2FkYSBjb3JyZWN0YW1lbnRlJyB9KVxuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBjb25zb2xlLmVycm9yKCdFcnJvciBhbCBhZ3JlZ2FyIHRyYW5zYWNjacOzbjonLCBlcnJvcilcbiAgICAgIHRvYXN0KHsgdGl0bGU6ICdFcnJvciBhbCBhZ3JlZ2FyIGxhIHRyYW5zYWNjacOzbicgfSlcbiAgICAgIHRocm93IGVycm9yXG4gICAgfVxuICB9XG5cbiAgLy8gQWN0dWFsaXphciB1bmEgdHJhbnNhY2Npw7NuIGV4aXN0ZW50ZVxuICBjb25zdCB1cGRhdGVUcmFuc2FjdGlvbiA9IGFzeW5jIChpZDogc3RyaW5nLCB0cmFuc2FjdGlvbjogUGFydGlhbDxUcmFuc2FjdGlvbj4pID0+IHtcbiAgICBpZiAoIXN1cGFiYXNlKSByZXR1cm5cblxuICAgIHRyeSB7XG4gICAgICAvLyBBZGFwdGFyIGxvcyBjYW1wb3MgYWwgZXNxdWVtYSBkZSBleHBlbnNlc1xuICAgICAgY29uc3QgZXhwZW5zZVRvVXBkYXRlOiBhbnkgPSB7fVxuICAgICAgaWYgKHRyYW5zYWN0aW9uLmFtb3VudCAhPT0gdW5kZWZpbmVkKSBleHBlbnNlVG9VcGRhdGUuYW1vdW50ID0gdHJhbnNhY3Rpb24uYW1vdW50XG4gICAgICBpZiAodHJhbnNhY3Rpb24uZGVzY3JpcHRpb24gIT09IHVuZGVmaW5lZCkgZXhwZW5zZVRvVXBkYXRlLmRlc2NyaXB0aW9uID0gdHJhbnNhY3Rpb24uZGVzY3JpcHRpb25cbiAgICAgIGlmICh0cmFuc2FjdGlvbi5kYXRlICE9PSB1bmRlZmluZWQpIGV4cGVuc2VUb1VwZGF0ZS5kYXRlID0gdHJhbnNhY3Rpb24uZGF0ZVxuICAgICAgaWYgKHRyYW5zYWN0aW9uLmNhdGVnb3J5X2lkICE9PSB1bmRlZmluZWQpIGV4cGVuc2VUb1VwZGF0ZS5jYXRlZ29yeV9pZCA9IHRyYW5zYWN0aW9uLmNhdGVnb3J5X2lkXG4gICAgICBpZiAodHJhbnNhY3Rpb24udHlwZSAhPT0gdW5kZWZpbmVkKSBleHBlbnNlVG9VcGRhdGUudHlwZSA9IHRyYW5zYWN0aW9uLnR5cGVcblxuICAgICAgY29uc29sZS5sb2coJ0FjdHVhbGl6YW5kbyB0cmFuc2FjY2nDs246JywgeyBpZCwgLi4uZXhwZW5zZVRvVXBkYXRlIH0pXG5cbiAgICAgIGNvbnN0IHsgZGF0YSwgZXJyb3IgfSA9IGF3YWl0IHN1cGFiYXNlXG4gICAgICAgIC5mcm9tKCdleHBlbnNlcycpXG4gICAgICAgIC51cGRhdGUoZXhwZW5zZVRvVXBkYXRlKVxuICAgICAgICAuZXEoJ2lkJywgaWQpXG4gICAgICAgIC5zZWxlY3QoKVxuICAgICAgICAuc2luZ2xlKClcblxuICAgICAgaWYgKGVycm9yKSB0aHJvdyBlcnJvclxuXG4gICAgICBjb25zb2xlLmxvZygnVHJhbnNhY2Npw7NuIGFjdHVhbGl6YWRhOicsIGRhdGEpXG5cbiAgICAgIC8vIFJlY2FyZ2FyIHRvZGFzIGxhcyB0cmFuc2FjY2lvbmVzIHBhcmEgYXNlZ3VyYXIgY29uc2lzdGVuY2lhXG4gICAgICBjb25zdCB7IGRhdGE6IHRyYW5zYWN0aW9uc0RhdGEsIGVycm9yOiB0cmFuc2FjdGlvbnNFcnJvciB9ID0gYXdhaXQgc3VwYWJhc2VcbiAgICAgICAgLmZyb20oJ2V4cGVuc2VzJylcbiAgICAgICAgLnNlbGVjdCgnKicpXG4gICAgICAgIC5vcmRlcignY3JlYXRlZF9hdCcsIHsgYXNjZW5kaW5nOiBmYWxzZSB9KVxuXG4gICAgICBpZiAodHJhbnNhY3Rpb25zRXJyb3IpIHRocm93IHRyYW5zYWN0aW9uc0Vycm9yXG5cbiAgICAgIGNvbnNvbGUubG9nKCdUcmFuc2FjY2lvbmVzIGFjdHVhbGl6YWRhczonLCB0cmFuc2FjdGlvbnNEYXRhKVxuICAgICAgc2V0VHJhbnNhY3Rpb25zKHRyYW5zYWN0aW9uc0RhdGEgfHwgW10pXG4gICAgICB0b2FzdCh7IHRpdGxlOiAnVHJhbnNhY2Npw7NuIGFjdHVhbGl6YWRhIGNvcnJlY3RhbWVudGUnIH0pXG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoJ0Vycm9yIGFsIGFjdHVhbGl6YXIgdHJhbnNhY2Npw7NuOicsIGVycm9yKVxuICAgICAgdG9hc3QoeyB0aXRsZTogJ0Vycm9yIGFsIGFjdHVhbGl6YXIgbGEgdHJhbnNhY2Npw7NuJyB9KVxuICAgICAgdGhyb3cgZXJyb3JcbiAgICB9XG4gIH1cblxuICAvLyBFbGltaW5hciB1bmEgdHJhbnNhY2Npw7NuXG4gIGNvbnN0IGRlbGV0ZVRyYW5zYWN0aW9uID0gYXN5bmMgKGlkOiBzdHJpbmcpID0+IHtcbiAgICBpZiAoIXN1cGFiYXNlKSByZXR1cm5cblxuICAgIHRyeSB7XG4gICAgICBjb25zb2xlLmxvZygnRWxpbWluYW5kbyB0cmFuc2FjY2nDs246JywgaWQpXG5cbiAgICAgIGNvbnN0IHsgZXJyb3IgfSA9IGF3YWl0IHN1cGFiYXNlLmZyb20oJ2V4cGVuc2VzJykuZGVsZXRlKCkuZXEoJ2lkJywgaWQpXG5cbiAgICAgIGlmIChlcnJvcikgdGhyb3cgZXJyb3JcblxuICAgICAgLy8gUmVjYXJnYXIgdG9kYXMgbGFzIHRyYW5zYWNjaW9uZXMgcGFyYSBhc2VndXJhciBjb25zaXN0ZW5jaWFcbiAgICAgIGNvbnN0IHsgZGF0YTogdHJhbnNhY3Rpb25zRGF0YSwgZXJyb3I6IHRyYW5zYWN0aW9uc0Vycm9yIH0gPSBhd2FpdCBzdXBhYmFzZVxuICAgICAgICAuZnJvbSgnZXhwZW5zZXMnKVxuICAgICAgICAuc2VsZWN0KCcqJylcbiAgICAgICAgLm9yZGVyKCdjcmVhdGVkX2F0JywgeyBhc2NlbmRpbmc6IGZhbHNlIH0pXG5cbiAgICAgIGlmICh0cmFuc2FjdGlvbnNFcnJvcikgdGhyb3cgdHJhbnNhY3Rpb25zRXJyb3JcblxuICAgICAgY29uc29sZS5sb2coJ1RyYW5zYWNjaW9uZXMgYWN0dWFsaXphZGFzOicsIHRyYW5zYWN0aW9uc0RhdGEpXG4gICAgICBzZXRUcmFuc2FjdGlvbnModHJhbnNhY3Rpb25zRGF0YSB8fCBbXSlcbiAgICAgIHRvYXN0KHsgdGl0bGU6ICdUcmFuc2FjY2nDs24gZWxpbWluYWRhIGNvcnJlY3RhbWVudGUnIH0pXG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoJ0Vycm9yIGFsIGVsaW1pbmFyIHRyYW5zYWNjacOzbjonLCBlcnJvcilcbiAgICAgIHRvYXN0KHsgdGl0bGU6ICdFcnJvciBhbCBlbGltaW5hciBsYSB0cmFuc2FjY2nDs24nIH0pXG4gICAgICB0aHJvdyBlcnJvclxuICAgIH1cbiAgfVxuXG4gIC8vIE9idGVuZXIgdHJhbnNhY2Npb25lcyBkZSB1biBtZXMgZXNwZWPDrWZpY29cbiAgY29uc3QgZ2V0TW9udGhUcmFuc2FjdGlvbnMgPSAobW9udGg6IHN0cmluZykgPT4ge1xuICAgIHJldHVybiB0cmFuc2FjdGlvbnMuZmlsdGVyKCh0KSA9PiB0LmRhdGUuc3RhcnRzV2l0aChtb250aCkpXG4gIH1cblxuICAvLyBPYnRlbmVyIHJlc3VtZW4gZGUgdW4gbWVzIGVzcGVjw61maWNvXG4gIGNvbnN0IGdldE1vbnRoU3VtbWFyeSA9IChtb250aDogc3RyaW5nKTogTW9udGhTdW1tYXJ5ID0+IHtcbiAgICBjb25zdCBtb250aFRyYW5zYWN0aW9ucyA9IGdldE1vbnRoVHJhbnNhY3Rpb25zKG1vbnRoKVxuICAgIGNvbnN0IGluY29tZSA9IG1vbnRoVHJhbnNhY3Rpb25zXG4gICAgICAuZmlsdGVyKCh0KSA9PiB0LnR5cGUgPT09ICdpbmdyZXNvJylcbiAgICAgIC5yZWR1Y2UoKHN1bSwgdCkgPT4gc3VtICsgdC5hbW91bnQsIDApXG4gICAgY29uc3QgZXhwZW5zZSA9IG1vbnRoVHJhbnNhY3Rpb25zXG4gICAgICAuZmlsdGVyKCh0KSA9PiB0LnR5cGUgPT09ICdnYXN0bycpXG4gICAgICAucmVkdWNlKChzdW0sIHQpID0+IHN1bSArIHQuYW1vdW50LCAwKVxuXG4gICAgcmV0dXJuIHtcbiAgICAgIG1vbnRoLFxuICAgICAgaW5jb21lLFxuICAgICAgZXhwZW5zZSxcbiAgICAgIGJhbGFuY2U6IGluY29tZSAtIGV4cGVuc2UsXG4gICAgfVxuICB9XG5cbiAgLy8gT2J0ZW5lciByZXN1bWVuIHBvciBjYXRlZ29yw61hIHBhcmEgdW4gbWVzIGVzcGVjw61maWNvXG4gIGNvbnN0IGdldE1vbnRoQ2F0ZWdvcnlTdW1tYXJ5ID0gKG1vbnRoOiBzdHJpbmcsIHR5cGU6ICdpbmdyZXNvJyB8ICdnYXN0bycpID0+IHtcbiAgICBjb25zdCBtb250aFRyYW5zYWN0aW9ucyA9IGdldE1vbnRoVHJhbnNhY3Rpb25zKG1vbnRoKS5maWx0ZXIoKHQpID0+IHQudHlwZSA9PT0gdHlwZSlcbiAgICBjb25zdCBjYXRlZ29yeVN1bW1hcnk6IFJlY29yZDxzdHJpbmcsIG51bWJlcj4gPSB7fVxuXG4gICAgbW9udGhUcmFuc2FjdGlvbnMuZm9yRWFjaCgodHJhbnNhY3Rpb24pID0+IHtcbiAgICAgIGlmICghY2F0ZWdvcnlTdW1tYXJ5W3RyYW5zYWN0aW9uLmNhdGVnb3J5X2lkXSkge1xuICAgICAgICBjYXRlZ29yeVN1bW1hcnlbdHJhbnNhY3Rpb24uY2F0ZWdvcnlfaWRdID0gMFxuICAgICAgfVxuICAgICAgY2F0ZWdvcnlTdW1tYXJ5W3RyYW5zYWN0aW9uLmNhdGVnb3J5X2lkXSArPSB0cmFuc2FjdGlvbi5hbW91bnRcbiAgICB9KVxuXG4gICAgcmV0dXJuIE9iamVjdC5lbnRyaWVzKGNhdGVnb3J5U3VtbWFyeSlcbiAgICAgIC5tYXAoKFtjYXRlZ29yeSwgYW1vdW50XSkgPT4gKHtcbiAgICAgICAgY2F0ZWdvcnksXG4gICAgICAgIGFtb3VudCxcbiAgICAgIH0pKVxuICAgICAgLnNvcnQoKGEsIGIpID0+IGIuYW1vdW50IC0gYS5hbW91bnQpXG4gIH1cblxuICAvLyBPYnRlbmVyIGxvcyDDumx0aW1vcyA2IG1lc2VzIHBhcmEgZWwgZ3LDoWZpY28gZGUgYmFycmFzXG4gIGNvbnN0IGdldExhc3RTaXhNb250aHNTdW1tYXJ5ID0gKCk6IE1vbnRoU3VtbWFyeVtdID0+IHtcbiAgICBjb25zdCB0b2RheSA9IG5ldyBEYXRlKClcbiAgICBjb25zdCBtb250aHM6IHN0cmluZ1tdID0gW11cblxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgNjsgaSsrKSB7XG4gICAgICBjb25zdCBkID0gbmV3IERhdGUodG9kYXkuZ2V0RnVsbFllYXIoKSwgdG9kYXkuZ2V0TW9udGgoKSAtIGksIDEpXG4gICAgICBjb25zdCBtb250aCA9IGAke2QuZ2V0RnVsbFllYXIoKX0tJHtTdHJpbmcoZC5nZXRNb250aCgpICsgMSkucGFkU3RhcnQoMiwgJzAnKX1gXG4gICAgICBtb250aHMucHVzaChtb250aClcbiAgICB9XG5cbiAgICByZXR1cm4gbW9udGhzLm1hcCgobW9udGgpID0+IGdldE1vbnRoU3VtbWFyeShtb250aCkpLnJldmVyc2UoKVxuICB9XG5cbiAgLy8gT2J0ZW5lciB0b2RvcyBsb3MgbWVzZXMgZGVsIGHDsW8gYWN0dWFsIHBhcmEgZWwgZ3LDoWZpY28gZGUgbMOtbmVhc1xuICBjb25zdCBnZXRBbGxNb250aHNTdW1tYXJ5ID0gKCk6IE1vbnRoU3VtbWFyeVtdID0+IHtcbiAgICAvLyBPYnRlbmVyIHRvZG9zIGxvcyBtZXNlcyDDum5pY29zIGRlIGxhcyB0cmFuc2FjY2lvbmVzXG4gICAgY29uc3QgbW9udGhzID0gQXJyYXkuZnJvbShuZXcgU2V0KHRyYW5zYWN0aW9ucy5tYXAodCA9PiB0LmRhdGUuc3Vic3RyaW5nKDAsIDcpKSkpXG4gICAgICAuc29ydCgoYSwgYikgPT4gYi5sb2NhbGVDb21wYXJlKGEpKSAvLyBPcmRlbmFyIGRlIG3DoXMgcmVjaWVudGUgYSBtw6FzIGFudGlndW9cblxuICAgIHJldHVybiBtb250aHMubWFwKG1vbnRoID0+IHtcbiAgICAgIGNvbnN0IG1vbnRoVHJhbnNhY3Rpb25zID0gdHJhbnNhY3Rpb25zLmZpbHRlcih0ID0+IHQuZGF0ZS5zdGFydHNXaXRoKG1vbnRoKSlcbiAgICAgIGNvbnN0IGluY29tZSA9IG1vbnRoVHJhbnNhY3Rpb25zXG4gICAgICAgIC5maWx0ZXIodCA9PiB0LnR5cGUgPT09ICdpbmdyZXNvJylcbiAgICAgICAgLnJlZHVjZSgoc3VtLCB0KSA9PiBzdW0gKyBOdW1iZXIodC5hbW91bnQpLCAwKVxuICAgICAgY29uc3QgZXhwZW5zZSA9IG1vbnRoVHJhbnNhY3Rpb25zXG4gICAgICAgIC5maWx0ZXIodCA9PiB0LnR5cGUgPT09ICdnYXN0bycpXG4gICAgICAgIC5yZWR1Y2UoKHN1bSwgdCkgPT4gc3VtICsgTnVtYmVyKHQuYW1vdW50KSwgMClcblxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgbW9udGgsXG4gICAgICAgIGluY29tZSxcbiAgICAgICAgZXhwZW5zZSxcbiAgICAgICAgYmFsYW5jZTogaW5jb21lIC0gZXhwZW5zZVxuICAgICAgfVxuICAgIH0pXG4gIH1cblxuICAvLyBPYnRlbmVyIGVsIHZhbG9yIGRlbCBkw7NsYXIgcGFyYSB1biBtZXMgZXNwZWPDrWZpY29cbiAgY29uc3QgZ2V0RG9sbGFyVmFsdWUgPSAobW9udGg6IHN0cmluZyk6IERvbGxhclZhbHVlIHwgdW5kZWZpbmVkID0+IHtcbiAgICByZXR1cm4gZG9sbGFyVmFsdWVzLmZpbmQoKGQpID0+IGQubW9udGggPT09IG1vbnRoKVxuICB9XG5cbiAgLy8gQWN0dWFsaXphciBlbCB2YWxvciBkZWwgZMOzbGFyIHBhcmEgdW4gbWVzIGVzcGVjw61maWNvXG4gIGNvbnN0IHVwZGF0ZURvbGxhclZhbHVlID0gYXN5bmMgKG1vbnRoOiBzdHJpbmcsIHZhbHVlOiBudW1iZXIpID0+IHtcbiAgICBpZiAoIXN1cGFiYXNlKSB7XG4gICAgICBjb25zb2xlLmVycm9yKCdTdXBhYmFzZSBubyBlc3TDoSBpbmljaWFsaXphZG8nKVxuICAgICAgdGhyb3cgbmV3IEVycm9yKCdTdXBhYmFzZSBubyBlc3TDoSBpbmljaWFsaXphZG8nKVxuICAgIH1cblxuICAgIHRyeSB7XG4gICAgICAvLyAxLiBWZXJpZmljYXIgYXV0ZW50aWNhY2nDs25cbiAgICAgIGNvbnN0IHsgZGF0YTogeyB1c2VyIH0sIGVycm9yOiB1c2VyRXJyb3IgfSA9IGF3YWl0IHN1cGFiYXNlLmF1dGguZ2V0VXNlcigpXG4gICAgICBpZiAodXNlckVycm9yKSB7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoJ0Vycm9yIGFsIG9idGVuZXIgdXN1YXJpbzonLCB1c2VyRXJyb3IpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignRXJyb3IgYWwgb2J0ZW5lciB1c3VhcmlvJylcbiAgICAgIH1cbiAgICAgIGlmICghdXNlcikge1xuICAgICAgICBjb25zb2xlLmVycm9yKCdObyBoYXkgdXN1YXJpbyBhdXRlbnRpY2FkbycpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignTm8gaGF5IHVzdWFyaW8gYXV0ZW50aWNhZG8nKVxuICAgICAgfVxuXG4gICAgICBjb25zb2xlLmxvZygnSW50ZW50YW5kbyBhY3R1YWxpemFyIHZhbG9yIGRlbCBkw7NsYXI6JywgeyB1c2VyX2lkOiB1c2VyLmlkLCBtb250aCwgdmFsdWUgfSlcblxuICAgICAgLy8gSW50ZW50YXIgYWN0dWFsaXphciBwcmltZXJvXG4gICAgICBjb25zdCB7IGRhdGE6IHVwZGF0ZURhdGEsIGVycm9yOiB1cGRhdGVFcnJvciB9ID0gYXdhaXQgc3VwYWJhc2VcbiAgICAgICAgLmZyb20oJ2RvbGxhcl92YWx1ZXMnKVxuICAgICAgICAudXBkYXRlKHsgdmFsdWUgfSlcbiAgICAgICAgLmVxKCd1c2VyX2lkJywgdXNlci5pZClcbiAgICAgICAgLmVxKCdtb250aCcsIG1vbnRoKVxuICAgICAgICAuc2VsZWN0KClcbiAgICAgICAgLnNpbmdsZSgpXG5cbiAgICAgIC8vIFNpIG5vIGV4aXN0ZSBlbCByZWdpc3RybywgaW50ZW50YXIgaW5zZXJ0YXJcbiAgICAgIGlmICh1cGRhdGVFcnJvciAmJiB1cGRhdGVFcnJvci5jb2RlID09PSAnUEdSU1QxMTYnKSB7XG4gICAgICAgIGNvbnNvbGUubG9nKCdSZWdpc3RybyBubyBlbmNvbnRyYWRvLCBpbnRlbnRhbmRvIGluc2VydGFyLi4uJylcbiAgICAgICAgY29uc3QgeyBkYXRhOiBpbnNlcnREYXRhLCBlcnJvcjogaW5zZXJ0RXJyb3IgfSA9IGF3YWl0IHN1cGFiYXNlXG4gICAgICAgICAgLmZyb20oJ2RvbGxhcl92YWx1ZXMnKVxuICAgICAgICAgIC5pbnNlcnQoe1xuICAgICAgICAgICAgdXNlcl9pZDogdXNlci5pZCxcbiAgICAgICAgICAgIG1vbnRoLFxuICAgICAgICAgICAgdmFsdWUsXG4gICAgICAgICAgfSlcbiAgICAgICAgICAuc2VsZWN0KClcbiAgICAgICAgICAuc2luZ2xlKClcblxuICAgICAgICBpZiAoaW5zZXJ0RXJyb3IpIHtcbiAgICAgICAgICBjb25zb2xlLmVycm9yKCdFcnJvciBhbCBpbnNlcnRhcjonLCBpbnNlcnRFcnJvcilcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEVycm9yIGFsIGluc2VydGFyOiAke2luc2VydEVycm9yLm1lc3NhZ2V9YClcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIEFjdHVhbGl6YXIgZWwgZXN0YWRvIGxvY2FsXG4gICAgICAgIHNldERvbGxhclZhbHVlcyhwcmV2ID0+IHtcbiAgICAgICAgICBjb25zdCBuZXdWYWx1ZXMgPSBbLi4ucHJldl1cbiAgICAgICAgICBjb25zdCBpbmRleCA9IG5ld1ZhbHVlcy5maW5kSW5kZXgoZCA9PiBkLm1vbnRoID09PSBtb250aClcbiAgICAgICAgICBpZiAoaW5kZXggPj0gMCkge1xuICAgICAgICAgICAgbmV3VmFsdWVzW2luZGV4XSA9IGluc2VydERhdGFcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgbmV3VmFsdWVzLnB1c2goaW5zZXJ0RGF0YSlcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIG5ld1ZhbHVlc1xuICAgICAgICB9KVxuXG4gICAgICAgIC8vIEFjdHVhbGl6YXIgbG9jYWxTdG9yYWdlXG4gICAgICAgIGxvY2FsU3RvcmFnZS5zZXRJdGVtKGBkb2xsYXItdmFsdWVzLSR7c3RvcmFnZUlkfWAsIEpTT04uc3RyaW5naWZ5KGRvbGxhclZhbHVlcykpXG4gICAgICAgIFxuICAgICAgICByZXR1cm4gaW5zZXJ0RGF0YVxuICAgICAgfVxuXG4gICAgICBpZiAodXBkYXRlRXJyb3IpIHtcbiAgICAgICAgY29uc29sZS5lcnJvcignRXJyb3IgYWwgYWN0dWFsaXphcjonLCB1cGRhdGVFcnJvcilcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBFcnJvciBhbCBhY3R1YWxpemFyOiAke3VwZGF0ZUVycm9yLm1lc3NhZ2V9YClcbiAgICAgIH1cblxuICAgICAgLy8gQWN0dWFsaXphciBlbCBlc3RhZG8gbG9jYWxcbiAgICAgIHNldERvbGxhclZhbHVlcyhwcmV2ID0+IHtcbiAgICAgICAgY29uc3QgbmV3VmFsdWVzID0gWy4uLnByZXZdXG4gICAgICAgIGNvbnN0IGluZGV4ID0gbmV3VmFsdWVzLmZpbmRJbmRleChkID0+IGQubW9udGggPT09IG1vbnRoKVxuICAgICAgICBpZiAoaW5kZXggPj0gMCkge1xuICAgICAgICAgIG5ld1ZhbHVlc1tpbmRleF0gPSB1cGRhdGVEYXRhXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgbmV3VmFsdWVzLnB1c2godXBkYXRlRGF0YSlcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbmV3VmFsdWVzXG4gICAgICB9KVxuXG4gICAgICAvLyBBY3R1YWxpemFyIGxvY2FsU3RvcmFnZVxuICAgICAgbG9jYWxTdG9yYWdlLnNldEl0ZW0oYGRvbGxhci12YWx1ZXMtJHtzdG9yYWdlSWR9YCwgSlNPTi5zdHJpbmdpZnkoZG9sbGFyVmFsdWVzKSlcblxuICAgICAgcmV0dXJuIHVwZGF0ZURhdGFcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgY29uc29sZS5lcnJvcignRXJyb3IgYWwgYWN0dWFsaXphciBlbCB2YWxvciBkZWwgZMOzbGFyOicsIGVycm9yKVxuICAgICAgdGhyb3cgZXJyb3JcbiAgICB9XG4gIH1cblxuICByZXR1cm4gKFxuICAgIDxUcmFuc2FjdGlvbkNvbnRleHQuUHJvdmlkZXJcbiAgICAgIHZhbHVlPXt7XG4gICAgICAgIHRyYW5zYWN0aW9ucyxcbiAgICAgICAgZG9sbGFyVmFsdWVzLFxuICAgICAgICBhZGRUcmFuc2FjdGlvbixcbiAgICAgICAgdXBkYXRlVHJhbnNhY3Rpb24sXG4gICAgICAgIGRlbGV0ZVRyYW5zYWN0aW9uLFxuICAgICAgICBnZXRNb250aFRyYW5zYWN0aW9ucyxcbiAgICAgICAgZ2V0TW9udGhTdW1tYXJ5LFxuICAgICAgICBnZXRMYXN0U2l4TW9udGhzU3VtbWFyeSxcbiAgICAgICAgZ2V0QWxsTW9udGhzU3VtbWFyeSxcbiAgICAgICAgZ2V0RG9sbGFyVmFsdWUsXG4gICAgICAgIHVwZGF0ZURvbGxhclZhbHVlLFxuICAgICAgICBnZXRNb250aENhdGVnb3J5U3VtbWFyeSxcbiAgICAgICAgaXNMb2FkaW5nLFxuICAgICAgfX1cbiAgICA+XG4gICAgICB7Y2hpbGRyZW59XG4gICAgPC9UcmFuc2FjdGlvbkNvbnRleHQuUHJvdmlkZXI+XG4gIClcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHVzZVRyYW5zYWN0aW9ucygpIHtcbiAgY29uc3QgY29udGV4dCA9IHVzZUNvbnRleHQoVHJhbnNhY3Rpb25Db250ZXh0KVxuICBpZiAoY29udGV4dCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwidXNlVHJhbnNhY3Rpb25zIG11c3QgYmUgdXNlZCB3aXRoaW4gYSBUcmFuc2FjdGlvblByb3ZpZGVyXCIpXG4gIH1cbiAgcmV0dXJuIGNvbnRleHRcbn1cbiJdLCJuYW1lcyI6WyJjcmVhdGVDb250ZXh0IiwidXNlQ29udGV4dCIsInVzZUVmZmVjdCIsInVzZVN0YXRlIiwidXNlSWQiLCJ1c2VPcHRpbWlzdGljIiwidXNlVG9hc3QiLCJ1c2VTdXBhYmFzZSIsImZvcm1hdCIsInN1Yk1vbnRocyIsIlRyYW5zYWN0aW9uQ29udGV4dCIsInVuZGVmaW5lZCIsIlRyYW5zYWN0aW9uUHJvdmlkZXIiLCJjaGlsZHJlbiIsInN1cGFiYXNlIiwidHJhbnNhY3Rpb25zIiwic2V0VHJhbnNhY3Rpb25zIiwiZG9sbGFyVmFsdWVzIiwic2V0RG9sbGFyVmFsdWVzIiwiaXNMb2FkaW5nIiwic2V0SXNMb2FkaW5nIiwib3B0aW1pc3RpY1RyYW5zYWN0aW9ucyIsImFkZE9wdGltaXN0aWNUcmFuc2FjdGlvbiIsInN0YXRlIiwiYWN0aW9uIiwiZGF0YSIsIm1hcCIsInQiLCJpZCIsInRyYW5zYWN0aW9uIiwiZmlsdGVyIiwib3B0aW1pc3RpY0RvbGxhclZhbHVlcyIsImFkZE9wdGltaXN0aWNEb2xsYXJWYWx1ZSIsImV4aXN0aW5nSW5kZXgiLCJmaW5kSW5kZXgiLCJkIiwibW9udGgiLCJ0b2FzdCIsInN0b3JhZ2VJZCIsImNhY2hlZFRyYW5zYWN0aW9ucyIsImxvY2FsU3RvcmFnZSIsImdldEl0ZW0iLCJwYXJzZWRUcmFuc2FjdGlvbnMiLCJKU09OIiwicGFyc2UiLCJlIiwiY29uc29sZSIsImVycm9yIiwiY2FjaGVkRG9sbGFyVmFsdWVzIiwibG9hZERhdGEiLCJ1c2VyIiwidXNlckVycm9yIiwiYXV0aCIsImdldFVzZXIiLCJ0b2RheSIsIkRhdGUiLCJtb250aHMiLCJpIiwicHVzaCIsImxvZyIsInRyYW5zYWN0aW9uc0RhdGEiLCJ0cmFuc2FjdGlvbnNFcnJvciIsImZyb20iLCJzZWxlY3QiLCJlcSIsImd0ZSIsImxlbmd0aCIsImx0ZSIsIm9yZGVyIiwiYXNjZW5kaW5nIiwic2V0SXRlbSIsInN0cmluZ2lmeSIsImxvYWREb2xsYXJWYWx1ZXMiLCJ0aXRsZSIsImRlc2NyaXB0aW9uIiwiRXJyb3IiLCJtZXNzYWdlIiwidmFyaWFudCIsImFkZFRyYW5zYWN0aW9uIiwiZXhwZW5zZVRvSW5zZXJ0IiwiYW1vdW50IiwiZGF0ZSIsImNhdGVnb3J5X2lkIiwidXNlcl9pZCIsInR5cGUiLCJpbnNlcnQiLCJzaW5nbGUiLCJ1cGRhdGVUcmFuc2FjdGlvbiIsImV4cGVuc2VUb1VwZGF0ZSIsInVwZGF0ZSIsImRlbGV0ZVRyYW5zYWN0aW9uIiwiZGVsZXRlIiwiZ2V0TW9udGhUcmFuc2FjdGlvbnMiLCJzdGFydHNXaXRoIiwiZ2V0TW9udGhTdW1tYXJ5IiwibW9udGhUcmFuc2FjdGlvbnMiLCJpbmNvbWUiLCJyZWR1Y2UiLCJzdW0iLCJleHBlbnNlIiwiYmFsYW5jZSIsImdldE1vbnRoQ2F0ZWdvcnlTdW1tYXJ5IiwiY2F0ZWdvcnlTdW1tYXJ5IiwiZm9yRWFjaCIsIk9iamVjdCIsImVudHJpZXMiLCJjYXRlZ29yeSIsInNvcnQiLCJhIiwiYiIsImdldExhc3RTaXhNb250aHNTdW1tYXJ5IiwiZ2V0RnVsbFllYXIiLCJnZXRNb250aCIsIlN0cmluZyIsInBhZFN0YXJ0IiwicmV2ZXJzZSIsImdldEFsbE1vbnRoc1N1bW1hcnkiLCJBcnJheSIsIlNldCIsInN1YnN0cmluZyIsImxvY2FsZUNvbXBhcmUiLCJOdW1iZXIiLCJnZXREb2xsYXJWYWx1ZSIsImZpbmQiLCJ1cGRhdGVEb2xsYXJWYWx1ZSIsInZhbHVlIiwidXBkYXRlRGF0YSIsInVwZGF0ZUVycm9yIiwiY29kZSIsImluc2VydERhdGEiLCJpbnNlcnRFcnJvciIsInByZXYiLCJuZXdWYWx1ZXMiLCJpbmRleCIsIlByb3ZpZGVyIiwidXNlVHJhbnNhY3Rpb25zIiwiY29udGV4dCJdLCJpZ25vcmVMaXN0IjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./context/transaction-context.tsx\n"));

/***/ })

});